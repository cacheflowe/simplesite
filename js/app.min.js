class AppStore {

  constructor() {
    this.state = {};
    this.listeners = [];
    this.methods = {};
    window._store = this;
  }

  addListener(obj, key) {
    if(key) {
      if(!this.methods[key]) this.methods[key] = [];
      this.methods[key].push(obj);
    } else {
      this.listeners.push(obj);
    }
  }

  removeListener(obj, key) {
    if(key) {
      if(this.methods[key]) {
        const index = this.methods[key].indexOf(obj);
        if (index !== -1) this.methods[key].splice(index, 1);
      }
    } else {
      const index = this.listeners.indexOf(obj);
      if (index !== -1) this.listeners.splice(index, 1);
    }
  }

  set(key, value) {
    if(typeof key === "undefined") throw new Error('AppStore requires legit keys');
    this.state[key] = value;
    this.listeners.forEach((el, i, arr) => {
      el.storeUpdated(key, value);
    });
    // specific listener methods
    const objs = this.methods[key];
    if(objs) {
      objs.forEach((el) => {
        if(el[key]) el[key](value);
        else throw new Error('AppStore listener has no callback: ' + key);
      });
    }
  }

  get(key) {
    return this.state[key];
  }

  log() {
    for(let key in _store.state) {
      console.log(key, _store.state[key]);
    }
  }

}

class DOMUtil {

  static closest(element, selector) {
    selector = selector.toLowerCase();
    let className = selector.split('.').length > 1 ? selector.split('.')[1] : '';
    selector = selector.split('.')[0];
    while (true) {
      if (element.nodeName.toLowerCase() === selector && element.className.indexOf(className) !== -1) {
        return element;
      }
      if (!(element = element.parentNode)) {
        break;
      }
    }
    return null;
  }

  static remove(el) {
    if (el && el.parentNode) {
      return el.parentNode.removeChild(el);
    }
    return null;
  }

  static stringToDomElement(str) {
    let div = document.createElement('div');
    div.innerHTML = str;
    return div.firstChild;
  }

  static elementToString(el) {
    return el.outerHTML;
  }

  static addLoadedClass() { // add class to enable animation a moment after window load
    window.addEventListener('load', (e) => {
      setTimeout(() => {
        document.body.classList.add('ready');
      }, 1000);
    });
  }

  static isElementVisible(el) {
    var rect = el.getBoundingClientRect();
    return rect.bottom > 0 &&
        rect.right > 0 &&
        rect.left < (window.innerWidth || document.documentElement.clientWidth) &&
        rect.top < (window.innerHeight || document.documentElement.clientHeight);
  }

}

class EasyScroll {

  constructor(scrollEl=window) {
    this.scrollEl = scrollEl;
    this.startScrollY = 0;
    this.scrollDist = 0;
    this.frame = 0;
    this.frames = 0;
  }

  easeInOutQuad(t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t + b;
    return -c/2 * ((--t)*(t-2) - 1) + b;
  }

  animateScroll() {
    this.frame++;
    if(this.frame <= this.frames) requestAnimationFrame(() => this.animateScroll());
    let percentComplete = this.frame / this.frames;
    let scrollProgress = this.scrollDist * this.easeInOutQuad(percentComplete, 0, 1, 1);
    if(this.scrollEl == window) {
      window.scrollTo(0, Math.round((this.startScrollY - scrollProgress)));
    } else {
      this.scrollEl.scrollTop = Math.round(this.startScrollY - scrollProgress);
    }
  }

  scrollByY(duration, scrollAmount) {
    this.startScrollY = (this.scrollEl == window) ? window.scrollY : this.scrollEl.scrollTop;
    this.scrollDist = scrollAmount;
    this.frame = 0;
    this.frames = Math.floor(duration / 16);
    requestAnimationFrame(() => this.animateScroll());
  }

  scrollToEl(duration, el, offset) {
    let pageOffset = (this.scrollEl == window) ? 0 : this.scrollEl.getBoundingClientRect().top;
    this.scrollByY(duration, -el.getBoundingClientRect().top + offset + pageOffset);
  }

  setScrollEl(el) {
    this.scrollEl = el;
  }

}

class LazyImageLoader {

  constructor(el) {
    this.el = el;
    this.scrollHandler = null;
    // this.imgQueue = null;
    let imgNodes = this.el.querySelectorAll('[data-src]');
    this.imageEls = [];
    for(let i=0; i < imgNodes.length; i++) this.imageEls.push(imgNodes[i]);
    this.queuedEls = [];
    this.loading = false;
    this.queueVisibleImages();
    this.addScrollHandler();
  }

  // scroll handling

  addScrollHandler() {
    this.scrollHandler = this.scrolled.bind(this);
    window.addEventListener('scroll', this.scrollHandler);
  }

  removeScrollHandler() {
    if(this.scrollHandler == null) return;
    window.removeEventListener('scroll', this.scrollHandler);
    this.scrollHandler = null;
  }

  scrolled() {
    this.queueVisibleImages();
  }

  // check for visible images & queue them up

  queueVisibleImages() {
    // queue up visible images - splice in reverse
    let newVisibleImages = [];
    for (var i = this.imageEls.length - 1; i >= 0; i--) {
      if(DOMUtil.isElementVisible(this.imageEls[i])) {
        let visibleImg = this.imageEls.splice(i, 1)[0];
        newVisibleImages.push(visibleImg);
      }
    }
    // reverse found images and push into queue
    newVisibleImages.reverse();
    newVisibleImages.forEach((el, i) => {
      this.queuedEls.push(el);
    });
    // kick off loading if we're not already loading
    if(this.loading == false) this.loadNextImage();
    // clean up if all images are loaded
    if(this.imageEls.length == 0 && this.queuedEls.length == 0) {
      this.dispose();
    }
  }

  loadNextImage() {
    if(this.queuedEls.length > 0) {
      let curImg = this.queuedEls.shift();
      this.loadImage(curImg);
    }
  }

  loadImage(curImg) {
    this.loading = true;
    let img = new Image();
    // complete/error callbacks
    img.onload = () => {
      this.loading = false;
      this.cleanUpImg(curImg, img);
      this.loadNextImage();
    };
    img.onerror = () => {
      this.loading = false;
      this.loadNextImage();
    };
    // trigger load from image path
    img.src = curImg.getAttribute('data-src');
  }

  cleanUpImg(curImg, img) {
    if(curImg.getAttribute('data-src-bg')) {
      curImg.style.backgroundImage = `url(${img.src})`;
    } else {
      curImg.setAttribute('src', img.src);
    }
    curImg.removeAttribute('data-src-bg');
    curImg.removeAttribute('data-src');
  }

  // array helpers

  clearArray(array) {
    array.splice(0, array.length);
  }

  // lifecycle

	dispose() {
    this.removeScrollHandler();
    this.clearArray(this.imageEls);
    this.clearArray(this.queuedEls);
	}

}

class Lightbox {

  constructor() {
    this.lightboxDiv = null;
    this.lightboxImgUrl = null;
    this.lightboxImageLoader = null;
    this.active = false;

    // listen for close events
    document.addEventListener('click', (e) => this.hideLightbox(e));
    document.addEventListener('keyup', (e) => this.checkEscClose(e));
    window.addEventListener('scroll', (e) => this.hideLightbox(e));

    // check to open an image
    document.addEventListener('click', (e) => this.checkDocumentClick(e));
  }

  closest(element, tagname) {
    tagname = tagname.toLowerCase();
    while (true) {
      if (element.nodeName.toLowerCase() === tagname) return element;
      if (!(element = element.parentNode)) break;
    }
    return null;
  }

  checkDocumentClick(e) {
    // check links
    let clickedEl = this.closest(e.target, 'a');
    if(clickedEl && clickedEl.getAttribute('rel') == 'lightbox') {
      e.preventDefault();
      this.handleLightboxLink(clickedEl.href);
    }
    // check images
    let clickedImg = this.closest(e.target, 'img');
    if(clickedImg && clickedImg.classList.contains('imagexpander')) {
      e.preventDefault();
      this.handleLightboxLink(clickedImg.getAttribute('src'));
    }
  }

  handleLightboxLink(imageUrl) {
    // load image
    this.lightboxImgUrl = imageUrl;
    this.lightboxImageLoader = new Image();
    this.lightboxImageLoader.addEventListener('load', (e) => this.lightboxImageLoaded(e));
    this.lightboxImageLoader.src = this.lightboxImgUrl;
  }

  lightboxImageLoaded() {
    // check if we need to let the image display at natural size
    // console.log('this.lightboxImageLoader.height', this.lightboxImageLoader.height);
    var containedClass = (this.lightboxImageLoader.height < window.innerHeight - 40 && this.lightboxImageLoader.width < window.innerWidth - 40) ? 'lightbox-image-contained' : '';

    // add elements to body
    this.lightboxDiv = document.createElement('div');
    this.lightboxDiv.className = 'lightbox';
    this.lightboxDiv.innerHTML = '<div class="lightbox-image-holder '+ containedClass +'" style="background-image:url('+ this.lightboxImgUrl +')"></div>';
    document.body.appendChild(this.lightboxDiv);

    this.active = true;
    requestAnimationFrame(() => {
      this.lightboxDiv.className = 'lightbox';
      requestAnimationFrame(() => {
        this.lightboxDiv.className = 'lightbox showing';
      });
    });
  }

  checkEscClose(e) {
    if(e.keyCode == 27) {
      this.hideLightbox();
    }
  }

  hideLightbox(e) {
    if(!this.active) return;
    if(!this.lightboxDiv) return;
    this.active = false;
    this.lightboxDiv.className = 'lightbox';
    setTimeout(() => {
      document.body.removeChild(this.lightboxDiv);
    }, 300);
  }

}

class AreaModel {
  constructor(initRoutes, pathUpdatedCallback, defaultViewClass, cacheResponses=true, allowsCurPathReloading=false) {
    this.contentEl = document.getElementById('content-holder');
    this.pageTitleBase = document.title.split(' | ')[0];
    this.curPath = null;
    this.prevPath = null;
    this.queuedPath = null;
    this.curAreaObj = null;
    this.cachedResponses = (cacheResponses) ? {} : null;
    this.allowsCurPathReloading = allowsCurPathReloading;
    this.isTransitioning = false;
    this.easyScroll = new EasyScroll();
    this.pathUpdatedCallback = pathUpdatedCallback;
    this.defaultViewClass = defaultViewClass || 'BaseView';
    initRoutes(this.index.bind(this));
  }

  index() {
    if (!this.isTransitioning) {
      this.curPath = page.current;
      if (this.curPath == '' || this.curPath == '/') this.curPath = '/home';
      if (this.curPath !== this.prevPath || this.allowsCurPathReloading) {
        if(this.prevPath == null) this.updateSectionCssClass();
        if (window.scrollY > 20) {
          this.easyScroll.scrollByY(300, window.scrollY);
        }
        this.exitCurSection();
      }
    } else {
      this.queuedPath = page.current;
    }
  }

  exitCurSection() {
    if(this.prevPath == null) { // first load!
      this.sectionDataLoaded(this.contentEl.innerHTML, this.curPath);
    } else {
      this.isTransitioning = true;
      if (this.contentEl.children.length > 0) {
        document.body.classList.add('page-loading');
        return setTimeout(() => this.contentHidden(), 300);
      } else {
        return this.contentHidden();
      }
    }
  }

  contentHidden() {
    if (this.curAreaObj != null) {
      this.curAreaObj.dispose();
    }
    this.curAreaObj = null;
    return this.loadAjaxContent(this.curPath);
  }

  loadAjaxContent(path) {
    if (path.length > 1 && path[path.length - 1] === '/') {
      path = path.substr(0, path.length - 1);
    }

    // get area html path based on section
    if(this.cachedResponses && typeof this.cachedResponses[path] !== "undefined") {
      this.sectionDataLoaded(this.cachedResponses[path], path);
    } else {
      this.fetchPage(path);
    }
  }

  fetchPage(path) {
    fetch(path, {method: "POST"})
      .then(function(response) {
        return response.text();
      }).then((data) => {
        this.sectionDataLoaded(data, path);
      }).catch(function(ex) {
        console.warn('Fetch failed', ex);
      });
  }

  sectionDataLoaded(data, path) {
    if(this.cachedResponses) this.cachedResponses[path] = data;
    this.createMainContentObj(data);
    this.showNewContent();
  }

  createMainContentObj(data) {
    // create new content element
    var newContentEl;
    if (typeof data === "string") {
      newContentEl = this.stringToDomElement(data);
    } else {
      newContentEl = data;
    }
    // update <title>
    let pageTitle = newContentEl.getAttribute('data-page-title') || null;
    this.formatDocumentTitle(pageTitle);
    // create page object
    let pageType = newContentEl.getAttribute('data-view-type') || this.defaultViewClass;
    if(this.prevPath != null) this.contentEl.innerHTML = data;  // don't replace initial html
    this.curAreaObj = new window[pageType](this.contentEl);
  }

  showNewContent() {
    document.body.classList.remove('page-loading');
    if (this.curPath !== this.prevPath) this.updateSectionCssClass();
    this.prevPath = this.curPath;
    this.isTransitioning = false;
    if (this.queuedPath) {
      this.queuedPath = null;
      this.index();
    }
    if(this.pathUpdatedCallback) this.pathUpdatedCallback(this.curPath);
    // return setTimeout(((_this => () => ga('send', {
    //   hitType: 'pageview',
    //   page: location.pathname
    // })))(this), 200);
  }

  updateSectionCssClass() {
    if (this.prevPath && this.prevPath.length > 1) {
      let pathNoQuery = this.prevPath.split("?")[0];    // strip queryparams so they don't end up in classnames
      var pathSplit = pathNoQuery.substr(1).split('/');
      if(pathSplit.length > 0) document.body.classList.remove('section-' + pathSplit[0]);
      if(pathSplit.length > 1) document.body.classList.remove('subsection-' + pathSplit[1]);
    }
    if (this.curPath.length > 1) {
      let pathNoQuery = this.curPath.split("?")[0];
      var pathSplit = pathNoQuery.substr(1).split('/');
      if(pathSplit.length > 0) document.body.classList.add('section-' + pathSplit[0]);
      if(pathSplit.length > 1) document.body.classList.add('subsection-' + pathSplit[1]);
    }
  }

  stringToDomElement(str) {
    let div = document.createElement('div');
    div.innerHTML = str;
    return div.children[0];
  }

  formatDocumentTitle(newTitle) {
    document.title = (newTitle != null) ? newTitle : this.pageTitleBase;
  }

  toTitleCase(str) {
    return str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase();
  }

}

class BaseView {

  constructor(el) {
    this.el = el;
	}

  dispose() {
    this.el = null;
  }

}

window.BaseView = BaseView;

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.page = factory());
}(this, (function () { 'use strict';

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {String} str
 * @return {Array}
 */
function parse (str) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var suffix = res[6];
    var asterisk = res[7];

    var repeat = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';
    var delimiter = prefix || '/';
    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      pattern: escapeGroup(pattern)
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {String}   str
 * @return {Function}
 */
function compile (str) {
  return tokensToFunction(parse(str))
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^' + tokens[i].pattern + '$');
    }
  }

  return function (obj) {
    var path = '';
    var data = obj || {};

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encodeURIComponent(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = encodeURIComponent(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {String} str
 * @return {String}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function stringToRegexp (path, keys, options) {
  var tokens = parse(path);
  var re = tokensToRegExp(tokens, options);

  // Attach keys back to the regexp.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] !== 'string') {
      keys.push(tokens[i]);
    }
  }

  return attachKeys(re, keys)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {Array}  tokens
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function tokensToRegExp (tokens, options) {
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';
  var lastToken = tokens[tokens.length - 1];
  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken);

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = token.pattern;

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (prefix) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return new RegExp('^' + route, flags(options))
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isarray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options)
  }

  if (isarray(path)) {
    return arrayToRegexp(path, keys, options)
  }

  return stringToRegexp(path, keys, options)
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/**
   * Module dependencies.
   */



  /**
   * Short-cuts for global-object checks
   */

  var hasDocument = ('undefined' !== typeof document);
  var hasWindow = ('undefined' !== typeof window);
  var hasHistory = ('undefined' !== typeof history);
  var hasProcess = typeof process !== 'undefined';

  /**
   * Detect click event
   */
  var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var isLocation = hasWindow && !!(window.history.location || window.location);

  /**
   * The page instance
   * @api private
   */
  function Page() {
    // public things
    this.callbacks = [];
    this.exits = [];
    this.current = '';
    this.len = 0;

    // private things
    this._decodeURLComponents = true;
    this._base = '';
    this._strict = false;
    this._running = false;
    this._hashbang = false;

    // bound functions
    this.clickHandler = this.clickHandler.bind(this);
    this._onpopstate = this._onpopstate.bind(this);
  }

  /**
   * Configure the instance of page. This can be called multiple times.
   *
   * @param {Object} options
   * @api public
   */

  Page.prototype.configure = function(options) {
    var opts = options || {};

    this._window = opts.window || (hasWindow && window);
    this._decodeURLComponents = opts.decodeURLComponents !== false;
    this._popstate = opts.popstate !== false && hasWindow;
    this._click = opts.click !== false && hasDocument;
    this._hashbang = !!opts.hashbang;

    var _window = this._window;
    if(this._popstate) {
      _window.addEventListener('popstate', this._onpopstate, false);
    } else if(hasWindow) {
      _window.removeEventListener('popstate', this._onpopstate, false);
    }

    if (this._click) {
      _window.document.addEventListener(clickEvent, this.clickHandler, false);
    } else if(hasDocument) {
      _window.document.removeEventListener(clickEvent, this.clickHandler, false);
    }

    if(this._hashbang && hasWindow && !hasHistory) {
      _window.addEventListener('hashchange', this._onpopstate, false);
    } else if(hasWindow) {
      _window.removeEventListener('hashchange', this._onpopstate, false);
    }
  };

  /**
   * Get or set basepath to `path`.
   *
   * @param {string} path
   * @api public
   */

  Page.prototype.base = function(path) {
    if (0 === arguments.length) return this._base;
    this._base = path;
  };

  /**
   * Gets the `base`, which depends on whether we are using History or
   * hashbang routing.

   * @api private
   */
  Page.prototype._getBase = function() {
    var base = this._base;
    if(!!base) return base;
    var loc = hasWindow && this._window && this._window.location;

    if(hasWindow && this._hashbang && loc && loc.protocol === 'file:') {
      base = loc.pathname;
    }

    return base;
  };

  /**
   * Get or set strict path matching to `enable`
   *
   * @param {boolean} enable
   * @api public
   */

  Page.prototype.strict = function(enable) {
    if (0 === arguments.length) return this._strict;
    this._strict = enable;
  };


  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  Page.prototype.start = function(options) {
    var opts = options || {};
    this.configure(opts);

    if (false === opts.dispatch) return;
    this._running = true;

    var url;
    if(isLocation) {
      var window = this._window;
      var loc = window.location;

      if(this._hashbang && ~loc.hash.indexOf('#!')) {
        url = loc.hash.substr(2) + loc.search;
      } else if (this._hashbang) {
        url = loc.search + loc.hash;
      } else {
        url = loc.pathname + loc.search + loc.hash;
      }
    }

    this.replace(url, null, true, opts.dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  Page.prototype.stop = function() {
    if (!this._running) return;
    this.current = '';
    this.len = 0;
    this._running = false;

    var window = this._window;
    this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);
    hasWindow && window.removeEventListener('popstate', this._onpopstate, false);
    hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} dispatch
   * @param {boolean=} push
   * @return {!Context}
   * @api public
   */

  Page.prototype.show = function(path, state, dispatch, push) {
    var ctx = new Context(path, state, this),
      prev = this.prevContext;
    this.prevContext = ctx;
    this.current = ctx.path;
    if (false !== dispatch) this.dispatch(ctx, prev);
    if (false !== ctx.handled && false !== push) ctx.pushState();
    return ctx;
  };

  /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object=} state
   * @api public
   */

  Page.prototype.back = function(path, state) {
    var page = this;
    if (this.len > 0) {
      var window = this._window;
      // this may need more testing to see if all browsers
      // wait for the next tick to go back in history
      hasHistory && window.history.back();
      this.len--;
    } else if (path) {
      setTimeout(function() {
        page.show(path, state);
      });
    } else {
      setTimeout(function() {
        page.show(page._getBase(), state);
      });
    }
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {string} from - if param 'to' is undefined redirects to 'from'
   * @param {string=} to
   * @api public
   */
  Page.prototype.redirect = function(from, to) {
    var inst = this;

    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page.call(this, from, function(e) {
        setTimeout(function() {
          inst.replace(/** @type {!string} */ (to));
        }, 0);
      });
    }

    // Wait for the push state and replace it with another
    if ('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
        inst.replace(from);
      }, 0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} init
   * @param {boolean=} dispatch
   * @return {!Context}
   * @api public
   */


  Page.prototype.replace = function(path, state, init, dispatch) {
    var ctx = new Context(path, state, this),
      prev = this.prevContext;
    this.prevContext = ctx;
    this.current = ctx.path;
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) this.dispatch(ctx, prev);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Context} ctx
   * @api private
   */

  Page.prototype.dispatch = function(ctx, prev) {
    var i = 0, j = 0, page = this;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];

      if (ctx.path !== page.current) {
        ctx.handled = false;
        return;
      }
      if (!fn) return unhandled.call(page, ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  Page.prototype.exit = function(path, fn) {
    if (typeof path === 'function') {
      return this.exit('*', path);
    }

    var route = new Route(path, null, this);
    for (var i = 1; i < arguments.length; ++i) {
      this.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
   * Handle "click" events.
   */

  /* jshint +W054 */
  Page.prototype.clickHandler = function(e) {
    if (1 !== this._which(e)) return;

    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    // use shadow dom when available if not, fall back to composedPath()
    // for browsers that only have shady
    var el = e.target;
    var eventPath = e.path || (e.composedPath ? e.composedPath() : null);

    if(eventPath) {
      for (var i = 0; i < eventPath.length; i++) {
        if (!eventPath[i].nodeName) continue;
        if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;
        if (!eventPath[i].href) continue;

        el = eventPath[i];
        break;
      }
    }

    // continue ensure link
    // el.nodeName for svg links are 'a' instead of 'A'
    while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;
    if (!el || 'A' !== el.nodeName.toUpperCase()) return;

    // check if link is inside an svg
    // in this case, both href and target are always inside an object
    var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';

    // Ignore if tag has
    // 1. "download" attribute
    // 2. rel="external" attribute
    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if(!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf('mailto:') > -1) return;

    // check target
    // svg target is an object and its desired value is in .baseVal property
    if (svg ? el.target.baseVal : el.target) return;

    // x-origin
    // note: svg links that are not relative don't call click events (and skip page.js)
    // consequently, all svg links tested inside page.js are relative and in the same origin
    if (!svg && !this.sameOrigin(el.href)) return;

    // rebuild path
    // There aren't .pathname and .search properties in svg links, so we use href
    // Also, svg href is an object and its desired value is in .baseVal property
    var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));

    path = path[0] !== '/' ? '/' + path : path;

    // strip leading "/[drive letter]:" on NW.js on Windows
    if (hasProcess && path.match(/^\/[a-zA-Z]:\//)) {
      path = path.replace(/^\/[a-zA-Z]:\//, '/');
    }

    // same page
    var orig = path;
    var pageBase = this._getBase();

    if (path.indexOf(pageBase) === 0) {
      path = path.substr(pageBase.length);
    }

    if (this._hashbang) path = path.replace('#!', '');

    if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {
      return;
    }

    e.preventDefault();
    this.show(orig);
  };

  /**
   * Handle "populate" events.
   * @api private
   */

  Page.prototype._onpopstate = (function () {
    var loaded = false;
    if ( ! hasWindow ) {
      return function () {};
    }
    if (hasDocument && document.readyState === 'complete') {
      loaded = true;
    } else {
      window.addEventListener('load', function() {
        setTimeout(function() {
          loaded = true;
        }, 0);
      });
    }
    return function onpopstate(e) {
      if (!loaded) return;
      var page = this;
      if (e.state) {
        var path = e.state.path;
        page.replace(path, e.state);
      } else if (isLocation) {
        var loc = page._window.location;
        page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);
      }
    };
  })();

  /**
   * Event button.
   */
  Page.prototype._which = function(e) {
    e = e || (hasWindow && this._window.event);
    return null == e.which ? e.button : e.which;
  };

  /**
   * Convert to a URL object
   * @api private
   */
  Page.prototype._toURL = function(href) {
    var window = this._window;
    if(typeof URL === 'function' && isLocation) {
      return new URL(href, window.location.toString());
    } else if (hasDocument) {
      var anc = window.document.createElement('a');
      anc.href = href;
      return anc;
    }
  };

  /**
   * Check if `href` is the same origin.
   * @param {string} href
   * @api public
   */

  Page.prototype.sameOrigin = function(href) {
    if(!href || !isLocation) return false;

    var url = this._toURL(href);
    var window = this._window;

    var loc = window.location;

    /*
       when the port is the default http port 80, internet explorer 11
       returns an empty string for loc.port, so we need to compare loc.port
       with an empty string if url.port is the default port 80.
    */
    return loc.protocol === url.protocol &&
      loc.hostname === url.hostname &&
      (loc.port === url.port || loc.port === '' && url.port === 80);
  };

  /**
   * @api private
   */
  Page.prototype._samePath = function(url) {
    if(!isLocation) return false;
    var window = this._window;
    var loc = window.location;
    return url.pathname === loc.pathname &&
      url.search === loc.search;
  };

  /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {string} val - URL component to decode
   * @api private
   */
  Page.prototype._decodeURLEncodedURIComponent = function(val) {
    if (typeof val !== 'string') { return val; }
    return this._decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
  };

  /**
   * Create a new `page` instance and function
   */
  function createPage() {
    var pageInstance = new Page();

    function pageFn(/* args */) {
      return page.apply(pageInstance, arguments);
    }

    // Copy all of the things over. In 2.0 maybe we use setPrototypeOf
    pageFn.callbacks = pageInstance.callbacks;
    pageFn.exits = pageInstance.exits;
    pageFn.base = pageInstance.base.bind(pageInstance);
    pageFn.strict = pageInstance.strict.bind(pageInstance);
    pageFn.start = pageInstance.start.bind(pageInstance);
    pageFn.stop = pageInstance.stop.bind(pageInstance);
    pageFn.show = pageInstance.show.bind(pageInstance);
    pageFn.back = pageInstance.back.bind(pageInstance);
    pageFn.redirect = pageInstance.redirect.bind(pageInstance);
    pageFn.replace = pageInstance.replace.bind(pageInstance);
    pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);
    pageFn.exit = pageInstance.exit.bind(pageInstance);
    pageFn.configure = pageInstance.configure.bind(pageInstance);
    pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);
    pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);

    pageFn.create = createPage;

    Object.defineProperty(pageFn, 'len', {
      get: function(){
        return pageInstance.len;
      },
      set: function(val) {
        pageInstance.len = val;
      }
    });

    Object.defineProperty(pageFn, 'current', {
      get: function(){
        return pageInstance.current;
      },
      set: function(val) {
        pageInstance.current = val;
      }
    });

    // In 2.0 these can be named exports
    pageFn.Context = Context;
    pageFn.Route = Route;

    return pageFn;
  }

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {string|!Function|!Object} path
   * @param {Function=} fn
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page.call(this, '*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(/** @type {string} */ (path), null, this);
      for (var i = 1; i < arguments.length; ++i) {
        this.callbacks.push(route.middleware(arguments[i]));
      }
      // show <path> with [state]
    } else if ('string' === typeof path) {
      this['string' === typeof fn ? 'redirect' : 'show'](path, fn);
      // start [options]
    } else {
      this.start(path);
    }
  }

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */
  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;
    var page = this;
    var window = page._window;

    if (page._hashbang) {
      current = isLocation && this._getBase() + window.location.hash.replace('#!', '');
    } else {
      current = isLocation && window.location.pathname + window.location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    isLocation && (window.location.href = ctx.canonicalPath);
  }

  /**
   * Escapes RegExp characters in the given string.
   *
   * @param {string} s
   * @api private
   */
  function escapeRegExp(s) {
    return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @constructor
   * @param {string} path
   * @param {Object=} state
   * @api public
   */

  function Context(path, state, pageInstance) {
    var _page = this.page = pageInstance || page;
    var window = _page._window;
    var hashbang = _page._hashbang;

    var pageBase = _page._getBase();
    if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    var re = new RegExp('^' + escapeRegExp(pageBase));
    this.path = path.replace(re, '') || '/';
    if (hashbang) this.path = this.path.replace('#!', '') || '/';

    this.title = (hasDocument && window.document.title);
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
    this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
    this.params = {};

    // fragment
    this.hash = '';
    if (!hashbang) {
      if (!~this.path.indexOf('#')) return;
      var parts = this.path.split('#');
      this.path = this.pathname = parts[0];
      this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';
      this.querystring = this.querystring.split('#')[0];
    }
  }

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function() {
    var page = this.page;
    var window = page._window;
    var hashbang = page._hashbang;

    page.len++;
    if (hasHistory) {
        window.history.pushState(this.state, this.title,
          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
    }
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function() {
    var page = this.page;
    if (hasHistory) {
        page._window.history.replaceState(this.state, this.title,
          page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
    }
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @constructor
   * @param {string} path
   * @param {Object=} options
   * @api private
   */

  function Route(path, options, page) {
    var _page = this.page = page || globalPage;
    var opts = options || {};
    opts.strict = opts.strict || page._strict;
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);
  }

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn) {
    var self = this;
    return function(ctx, next) {
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {string} path
   * @param {Object} params
   * @return {boolean}
   * @api private
   */

  Route.prototype.match = function(path, params) {
    var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    delete params[0]

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      var val = this.page._decodeURLEncodedURIComponent(m[i]);
      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
        params[key.name] = val;
      }
    }

    return true;
  };


  /**
   * Module exports.
   */

  var globalPage = createPage();
  var page_js = globalPage;
  var default_1 = globalPage;

page_js.default = default_1;

return page_js;

})));

class SimpleSite {

  constructor() {
    DOMUtil.addLoadedClass();
    // if(!this.hasWebGL()) window.location.href = '/help';
    requestAnimationFrame(() => this.init());
  }

  hasWebGL() {
    var canvas = document.createElement( 'canvas' ); return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );
  }

  init() {
    this.appStore = new AppStore();
    this.appStore.addListener(this);
    this.tracking = new Tracking();
    this.initRoutes();
    this.initLocalhost();
    this.initExtras();
  }

  initLocalhost() {
    if(window.location.href.match('localhost')) {
      document.body.classList.add('localhost');
    }
  }

  storeUpdated(key, value) {
    if(key == SimpleSite.SET_CUR_PATH) page(value);
    if(key == SimpleSite.RELOAD_VIEW) _store.set(SimpleSite.SET_CUR_PATH, _store.get(SimpleSite.CUR_PATH));
    if(key == SimpleSite.LOADER_SHOW && value == true) document.body.classList.add('data-loading');
    if(key == SimpleSite.LOADER_SHOW && value == false) document.body.classList.remove('data-loading');
    if(key == SimpleSite.ALERT_ERROR) this.notyf.error(value);
    if(key == SimpleSite.ALERT_SUCCESS) this.notyf.success(value);
  }

  initRoutes() {
    this.areaModel = new AreaModel((index) => {
      page('', index);
      page('/', index);
      page('/:section', index);
      page('/:section/:id', index);
      page('/:section/:id/:params', index);
      // page('*', notfound);
      page();
    }, (curPath) => {
      _store.set(SimpleSite.CUR_PATH, curPath);
    }, 'BaseView', false, true);
  }

  // extras

  initExtras() {
    this.initToasts();
    this.initDarkThemeToggle();
    this.mainMenuToggle = new MainMenuToggle();
  }

  initToasts() {
    this.notyf = new Notyf({duration:5000});
  }

  initDarkThemeToggle() {
    document.body.addEventListener('click', (e) => {
      if(e.target && e.target.classList.contains('dark-theme-toggle')) {
        // set transition class
        document.documentElement.classList.add('transition-theme');
        // do the toggle and store it for later
        if(document.documentElement.hasAttribute("data-theme")) {
          requestAnimationFrame(() => document.documentElement.removeAttribute("data-theme"));
          window.localStorage.removeItem('dark-theme');
        } else {
          requestAnimationFrame(() => document.documentElement.setAttribute("data-theme", "dark"));
          window.localStorage.setItem('dark-theme', 'true');
        }
      }
    });
    // set initial state on window load
    if(window.localStorage.getItem('dark-theme') == 'true') document.documentElement.setAttribute("data-theme", "dark");
  }

}

SimpleSite.CUR_PATH = 'CUR_PATH';
SimpleSite.SET_CUR_PATH = 'SET_CUR_PATH';
SimpleSite.RELOAD_VIEW = 'RELOAD_VIEW';
SimpleSite.LOADER_SHOW = 'LOADER_SHOW';
SimpleSite.ALERT_SUCCESS = 'ALERT_SUCCESS';
SimpleSite.ALERT_ERROR = 'ALERT_ERROR';

window.simplesite = new SimpleSite();

class MainMenuToggle {

  constructor(el) {
    _store.addListener(this, SimpleSite.CUR_PATH);
    this.buildContentBlocker();
    this.el = document.querySelector('#main-nav-toggle');
    this.el.addEventListener('click', (e) => this.toggleClicked(e));
    this.contentBlocker.addEventListener('click', (e) => this.toggleClicked(e));
    window.addEventListener('resize', (e) => this.windowResized(e));
  }

  buildContentBlocker() {
    this.contentBlocker = document.createElement('div');
    this.contentBlocker.setAttribute('id', 'content-blocker');
    document.body.appendChild(this.contentBlocker);
  }

  toggleClicked(e) {
    document.body.classList.toggle('main-nav-drawer-open');
  }

  windowResized(e) {
    // clear out drawer open when larger than collapsed browser size
    if (window.innerWidth > 767 && document.body.classList.contains('main-nav-drawer-open')) {
      document.body.classList.remove('main-nav-drawer-open');
    }
  }

  CUR_PATH(val) {
    // hide menu upon navigation
    document.body.classList.remove('main-nav-drawer-open');
  }
}

class Tracking {

  constructor() {
    this.debug = true;
    _store.addListener(this);
    if(window.ga === undefined) window.ga = () => {};
  }

  event(category='test', action='click', label='', value=null) {
    // More info: https://developers.google.com/analytics/devguides/collection/analyticsjs/events
    window.ga('send', 'event', category, action, label, value);
    if(this.debug) console.log('Tracking.event()', category, action, label, value);
  }

  page(path=document.location.pathname) {
    // More info: https://developers.google.com/analytics/devguides/collection/analyticsjs/pages
    // More info: https://developers.google.com/analytics/devguides/collection/analyticsjs/single-page-applications
    window.ga('set', 'page', path); // sets the page for a single-page app, so subsequent events are tracked to this page
    window.ga('send', 'pageview');
    if(this.debug) console.log('Tracking.page()', path);
  }

  storeUpdated(key, value) {
    if(key == SimpleSite.CUR_PATH) this.page(_store.get(SimpleSite.CUR_PATH));
  }

}

class BaseSiteView extends BaseView {

  constructor(el) {
    super(el);
    // window.embetter.utils.initMediaPlayers(this.el, SimpleSite.mediaServices);
    // this.buildShareLinks();
    // prepLazyLoadImages();
    // window.cacheCart.parseLinks(this.el);
    this.buildContactForm();
    this.addImageZooming();
    this.lazyImageLoader = new LazyImageLoader(this.el);
	};

	/* Image zooming --------------------------------------*/

  addImageZooming() {
    this.mediumZoom = mediumZoom('[data-zoomable]', {
      margin: 24,
      background: '#999',
    });
  }

  removeImageZooming() {
    this.mediumZoom.detach();
  }

	/* Lazy-load images --------------------------------------*/
  // prepLazyLoadImages() {
  //   var images = $('.listing-image img');
  //   for( var i=0; i < images.length; i++ ) {
  //     console.log(images[i]);
  //     images[i].setAttribute('data-src',images[i].src);
  //     images[i].src = '/images/blank.gif';
  //   }
  // };

  /* Share links ---------------------------------------- */

  buildShareLinks() {
    this.shareOut = new ShareOut();
    var shareEl = this.el.querySelector('.share-out-links');
    if(shareEl !== null) {
      var titleEl = this.el.querySelector('h2');
      var summary = (titleEl !== null) ? titleEl.textContent : '';
      var firstImg = this.el.querySelector('img');
      var img = (firstImg !== null) ? firstImg.src : '';
      this.shareOut.setShareLinks(shareEl, document.location.href, summary, img);
    }
  };

  disposeShareLinks() {
    var shareEl = this.el.querySelector('.share-out-links');
    if(shareEl !== null) {
      this.shareOut.disposeShareLinks(shareEl);
      this.shareOut = null;
    }
  };

  /* Contact form ----------------------------------------*/

  buildContactForm() {
    this.contactForm = null;
    this.submitButton = null;
    this.emailInput = null;
    this.aboutInput = null;
    this.messageInput = null;


    this.contactForm = this.el.querySelector('#contactform');
    if(this.contactForm !== null) {
      // grab elements
      this.emailInput = document.getElementById("email-input");
      this.aboutInput = document.getElementById("about-input");
      this.messageInput = document.getElementById("message-input");
      this.submitButton = document.getElementById("contact-submit");
      // listen to submit button
      this.submitButton.addEventListener('click', (e) => this.submitForm(e));
      // populate email link
      var emailLink = document.getElementById('email-button');
      var emailAddy = emailLink.getAttribute('data-username')+'@'+emailLink.getAttribute('data-domain');
      emailLink.href = 'mailto:'+emailAddy;
      emailLink.innerHTML = emailAddy;
    }
  };

  submitForm(e) {
    if(this.validateForm() === true) {
      this.submitButton.setAttribute('disabled', 'disabled');
      document.body.classList.add('page-loading');
      // fetch('/contact/submit', {method: "POST", body:{email: this.emailInput.value, about: this.aboutInput.value, message: this.messageInput.value}})
      fetch('/contact/submit', {method: "POST", body: new FormData(this.contactForm)})
        .then((response) => {
          return response.text();
        }).then((data) => {
          this.insertContactResponse(data);
          document.body.classList.remove('page-loading');
        }).catch(function(ex) {
          console.warn('Submit failed', ex);
        });
    }
  };

  insertContactResponse(html) {
    this.contactForm.innerHTML = html;
  };

  disposeContactForm() {
    if(this.submitButton === null) return;
    this.submitButton.removeEventListener('click', (e) => this.submitForm(e));
  };

  validateForm() {
  	if(this.isValidEmail(this.emailInput.value) === false) {
  		alert('Please enter a valid email');
  		this.emailInput.focus();
  		return false;
  	}
    if (this.messageInput.value.length === 0) {
  		alert('Please enter a message');
  		this.messageInput.focus();
  		return false;
  	}
    return true;
  }

  isValidEmail(email) {
    var emailRegex = new RegExp(/^[+\w.-]+@\w[\w.-]+\.[\w.-]*[a-z][a-z]$/i);
    return emailRegex.test(email);
  };

  validateEmail(email) {
    var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
  };

  /* View lifecycle ----------------------------------------*/
	dispose() {
    // this.disposeShareLinks();
    this.disposeContactForm();
    // window.embetter.utils.disposePlayers();
    // window.cacheCart.disposeLinks(this.el);
    this.lazyImageLoader.dispose();
    this.removeImageZooming();
	};

}

window.BaseSiteView = BaseSiteView;

class ConfigView extends BaseSiteView {

  constructor(el) {
    super(el);
    this.initForm();
	}

  initForm() {
    // get form element
    this.form = this.el.querySelector('form');
    this.configSection = this.form.querySelector('#form-config');

    // add removable click handler
    this.formClickHandler = this.formClicked.bind(this);
    this.el.addEventListener('click', this.formClickHandler);
  }

  formClicked(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'button') {
      if(e.target.hasAttribute('data-form-submit')) {
        // prep submit
        e.preventDefault();
        _store.set(SimpleSite.LOADER_SHOW, true);
        var postData = {
          config: {}
        };

        // get config inputs & populate post sub-object
        let configInputs = this.configSection.querySelectorAll('input');
        for (var i = 0; i < configInputs.length; i++) {
          let inputType = configInputs[i].getAttribute('type');
          let inputKey = configInputs[i].getAttribute('id');
          let inputVal = (inputType != 'checkbox') ? configInputs[i].value : configInputs[i].checked;
          postData.config[inputKey] = inputVal;
        }

        // send request
        fetch(this.form.getAttribute('action'), {
          method: 'POST',
          body: JSON.stringify(postData)
        })
          .then(function(response) {
            return response.text();
          }).then((data) => {
            data = JSON.parse(data);  // get response
            if(data.success) _store.set(SimpleSite.ALERT_SUCCESS, "TopoTable saved");
            else             _store.set(SimpleSite.ALERT_ERROR, "Save failed");
            _store.set(SimpleSite.LOADER_SHOW, false);
          }).catch(function(ex) {
            _store.set(SimpleSite.ALERT_ERROR, 'Fetch failed: ' + ex.message);
            _store.set(SimpleSite.LOADER_SHOW, false);
          });
      }
    }
  }

  dispose() {
    super.dispose();
    this.el.removeEventListener('click', this.formClickHandler);
	}

}

window.ConfigView = ConfigView;

class CountView extends BaseSiteView {

  constructor(el) {
    super(el);
    this.initCountForm();
	}

  initCountForm() {
    this.countFormHandler = this.countFormClicked.bind(this);
    this.el.addEventListener('click', this.countFormHandler);
  }

  countFormClicked(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'button') {
      if(e.target.hasAttribute('data-count-add')) {
        e.preventDefault();
        // show loader
        document.body.classList.add('data-loading');
        let countEl = this.el.querySelector('#count');
        let addCount = e.target.getAttribute('data-count-add');

        fetch('/count/add/'+addCount, {
          method: 'get'
          // body: {}
        })
          .then(function(response) {
            return response.text();
          }).then((data) => {
            // set number and animate
            data = JSON.parse(data);
            let newCount = data.count;
            countEl.innerHTML = newCount;
            countEl.classList.remove('updated');
            setTimeout(() => countEl.classList.add('updated'), 10);
            // hide loader
            document.body.classList.remove('data-loading');
            // notyf
            _store.set(SimpleSite.ALERT_SUCCESS, "Count updated");
          }).catch(function(ex) {
            formResult.innerHTML = '<span style="color:red;">Fetch upload failed</span>';
            document.body.classList.remove('data-loading');
          });

      }
    }
  }

  dispose() {
    super.dispose();
    this.el.removeEventListener('click', this.countFormHandler);
	}

}

window.CountView = CountView;

class CustomText extends BaseSiteView {

  constructor(el) {
    super(el);
    this.initForm();
	}

  initForm() {
    this.form = this.el.querySelector('form');
    this.customtextFormHandler = this.customtextFormClicked.bind(this);
    this.el.addEventListener('click', this.customtextFormHandler);
  }
  customtextFormClicked(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'button') {
      if(e.target.hasAttribute('data-customtext-submit')) {
        e.preventDefault();
        document.body.classList.add('data-loading');
        // line 1
        let customtextEl = this.el.querySelector('#customtext');
        let inputText = customtextEl.value.trim().replace(/'/g, "’");
        let submitVal = (inputText.length > 0) ? inputText : null;
        // line 2
        let customtextEl2 = this.el.querySelector('#customtext-line-2');
        let inputText2 = customtextEl2.value.trim().replace(/'/g, "’");
        let submitVal2 = (inputText2.length > 0) ? inputText2 : null;

        // add clear button check
        var updating = true;
        if(e.target.hasAttribute('data-customtext-clear')) {
          customtextEl.value = '';
          customtextEl2.value = '';
          submitVal = null;
          submitVal2 = null;
          updating = false;
        }

        // send request
        fetch(this.form.getAttribute('action'), {
          method: 'POST',
          body: JSON.stringify({"customtext": submitVal, "customtext-line-2": submitVal2})
        })
          .then(function(response) {
            return response.text();
          }).then((data) => {
            data = JSON.parse(data);
            document.body.classList.remove('data-loading');
            // notyf
            if(updating) _store.set(SimpleSite.ALERT_SUCCESS, "Custom text updated");
            else         _store.set(SimpleSite.ALERT_SUCCESS, "Custom text cleared");
          }).catch(function(ex) {
            console.log(ex);
            document.body.classList.remove('data-loading');
            _store.set(SimpleSite.ALERT_ERROR, "Custom text not updated");
          });

      }
    }
  }

  dispose() {
    super.dispose();
    this.el.removeEventListener('click', this.customtextFormHandler);
	}

}

window.CustomText = CustomText;

class DashboardView extends BaseSiteView {

  constructor(el) {
    super(el);
    this.setScroll();
    this.interval = setInterval(() => this.refresh(), 30 * 1000);
	}

  setScroll() {
    let disposeTime = _store.get(DashboardView.DISPOSE_TIME);
    if(disposeTime && Date.now() - disposeTime < 2000) {
      document.body.scrollTop = _store.get(DashboardView.SCROLL_TOP);
    }
  }

  refresh() {
    // reload current page on interval
    _store.set(SimpleSite.RELOAD_VIEW, true);
    // store current scroll position
    _store.set(DashboardView.SCROLL_TOP, document.body.scrollTop);
    _store.set(DashboardView.DISPOSE_TIME, Date.now());
  }

  dispose() {
    super.dispose();
    window.clearInterval(this.interval);
	}

}

DashboardView.SCROLL_TOP = "SCROLL_TOP";
DashboardView.DISPOSE_TIME = "DISPOSE_TIME";

window.DashboardView = DashboardView;

class JsonEditorView extends BaseSiteView {

  constructor(el) {
    super(el);
    this.initForm();
	}

  initForm() {
    // get form element
    this.form = this.el.querySelector('form#json-editor-form');
    this.formDataPath = this.form.getAttribute('data-path');
    this.assetsListPath = this.form.getAttribute('data-assets-list-path');
    this.formContainer = this.form.querySelector('#json-editor-form-content');
    this.addFormListeners();

    // load assets, which loads form data (unless there's not data attribute for apps)
    // we need the assets list before we can build the media dropdown UI
    if(this.assetsListPath) this.loadAssetsData();
    else this.loadFormData();
    _store.set(SimpleSite.LOADER_SHOW, true);
  }

  //////////////////////////////////////
  // FORM COMPONENT LISTENERS
  //////////////////////////////////////

  addFormListeners() {
    // add removable click handler
    this.formClickHandler = this.formClicked.bind(this);
    this.el.addEventListener('click', this.formClickHandler);
    this.formSelectHandler = this.formDropDownSelected.bind(this);
    this.el.addEventListener('input', this.formSelectHandler);
    this.formTextUpdatedHandler = this.formTextUpdated.bind(this);
    this.form.addEventListener('input', this.formTextUpdatedHandler);
    this.formCheckboxHandler = this.formCheckboxUpdated.bind(this);
    this.form.addEventListener('input', this.formCheckboxHandler);
    this.formEnterSubmitBlocker = this.formKeyDown.bind(this);
    this.form.addEventListener('keydown', this.formEnterSubmitBlocker);
  }

  // button clicks

  formClicked(e) {
    // check for button clicks. preventDefault behavior, which might submit the form
    if(e.target && e.target.nodeName.toLowerCase() == 'button') {
      e.preventDefault();
      this.formButtonClick(e.target);
    }
  }

  formButtonClick(buttonEl) {
    // check for publish actions
    this.handlePublishActions(buttonEl);
    // then check for slide actions
    if(buttonEl.hasAttribute('data-slide-action')) {
      let slideAction = buttonEl.getAttribute('data-slide-action');
      let slideIndex = parseInt(buttonEl.getAttribute('data-slide-index'));
      this.handleSlideActions(buttonEl, slideIndex, slideAction);
    }
  }

  // dropdowns

  buildMediaDropdown(label, dataKey, curSelection, filter="", index=-1) { // filter regex example: /jpg|png/
    filter = (!filter) ? "" : filter; // allow passing in `null` for filter
    // build open tag whether it's a config or slide data property
    let dropDownEl = (index == -1) ?
      `
      <label for="config-${dataKey}">${label}</label>
      <select data-config-key="${dataKey}" id="config-${dataKey}" data-media-picker="true">
      ` :
      `
      <label for="slide-${index}-${dataKey}">${label}</label>
      <select data-slide-key="${dataKey}" id="slide-${index}-${dataKey}" data-slide-index="${index}" data-media-picker="true">
      `;
    // add file list <option>s
    this.assetsList.forEach((el, i) => {
      let fileNameArr = el.filePath.split('/');
      let fileName = fileNameArr[fileNameArr.length - 1]; // get just the filename from full upload path
      let isSelected = (curSelection == el.filePath) ? 'selected' : '';
      if(el.filePath.match(filter)) {
        dropDownEl += `<option value="${el.filePath}" ${isSelected}>${fileName}</option>`;
      }
    });
    dropDownEl += `</select>`;
    return dropDownEl;
  }

  buildTimeDropdown(label, dataKey, curSelection, index=-1) {
    // build open tag whether it's a config or slide data property
    let dropDownEl = (index == -1) ?
      `
      <label for="config-${dataKey}">${label}</label>
      <select data-config-key="${dataKey}" id="config-${dataKey}" data-time-picker="true">
      ` :
      `
      <label for="slide-${index}-${dataKey}">${label}</label>
      <select data-slide-key="${dataKey}" id="slide-${index}-${dataKey}" data-slide-index="${index}" data-time-picker="true">
      `;
    // add null option
    let nullSelected = (curSelection == -1) ? 'selected' : '';
    dropDownEl += `<option value="-1" ${nullSelected}>None</option>`;
    // add time <option>s
    let increment = 0.5; // 15-minute increments
    let hours = 24;
    let numOptions = Math.round(1 / increment) * hours;
    for (var i = 0; i < numOptions; i++) {
      var hourVal = increment * i;
      var hour = Math.floor(hourVal);
      var hourStr = Math.floor(hourVal) % 12;
      if(hourStr == 0) hourStr = 12;
      var minutesStr = (hourVal % 1) * 60;
      if(hourStr < 10) hourStr = '0' + hourStr;
      if(minutesStr < 10) minutesStr = '0' + minutesStr;
      let amPm = (hour >= 12) ? 'pm' : 'am';
      let isSelected = (curSelection == hourVal) ? 'selected' : '';
      dropDownEl += `<option value="${hourVal}" ${isSelected}>${hourStr}:${minutesStr}${amPm}</option>`;
    }
    dropDownEl += `</select>`;
    return dropDownEl;
  }

  formDropDownSelected(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'select') {
      let dropDownEl = e.target;
      if(dropDownEl.hasAttribute('data-media-picker')) {
        this.mediaSelected(dropDownEl);
      } else if(dropDownEl.hasAttribute('data-time-picker')) {
        this.timeSelected(dropDownEl);
      }
    }
  }

  mediaSelected(dropDownEl) {
    let selectedAsset = dropDownEl.value;
    if(dropDownEl.hasAttribute('data-slide-key')) {
      let dataKey = dropDownEl.getAttribute('data-slide-key');
      let slideIndex = parseInt(dropDownEl.getAttribute('data-slide-index'));
      this.slidesData[slideIndex][dataKey] = selectedAsset;
    } else if(dropDownEl.hasAttribute('data-config-key')) {
      let dataKey = dropDownEl.getAttribute('data-config-key');
      this.configData[dataKey] = selectedAsset;
    }
    // refresh UI, since image and video might need to be recreated
    this.rebuildForm();
  }

  timeSelected(dropDownEl) {
    let selectedTime = parseFloat(dropDownEl.value);
    if(dropDownEl.hasAttribute('data-slide-key')) {
      let dataKey = dropDownEl.getAttribute('data-slide-key');
      let slideIndex = parseInt(dropDownEl.getAttribute('data-slide-index'));
      this.slidesData[slideIndex][dataKey] = selectedTime;
    } else if(dropDownEl.hasAttribute('data-config-key')) {
      let dataKey = dropDownEl.getAttribute('data-config-key');
      this.configData[dataKey] = selectedTime;
    }
  }

  mediaNodeFromAsset(assetURL) {
    return (assetURL.match(/.mp4/)) ?
      `<video class="slide-asset-preview" src="/${assetURL}" controls playsinline muted loops>` :
      `<img class="slide-asset-preview transparent-bg" src="/${assetURL}">`;
  }

  // checkbox toggled

  buildCheckbox(label, dataKey, value, index=-1) {   // negative index to denote configData object
    let inputId = dataKey + '-' + index;
    let checkedAttr = (value == true) ? "checked" : "";
    return `
      <label for="${inputId}">${label}</label>
      <label class="toggle" for="${inputId}">
        <input type="checkbox" id="${inputId}" data-slide-key="${dataKey}" data-slide-index="${index}" ${checkedAttr} />
        <span class="toggle-slider round"></span>
      </label>
    `;
  }

  formCheckboxUpdated(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'input' && e.target.getAttribute("type") == "checkbox") {
      this.checkboxUpdated(e.target);
    }
  }

  checkboxUpdated(checkBoxEl) {
    let dataKey = checkBoxEl.getAttribute('data-slide-key');
    let slideIndex = parseInt(checkBoxEl.getAttribute('data-slide-index'));
    if(slideIndex >= 0) {
      this.slidesData[slideIndex][dataKey] = checkBoxEl.checked;
    } else {
      this.configData[dataKey] = checkBoxEl.checked;
    }
  }

  // text updated in text input/texturea

  buildTextInput(label, dataKey, curValue, index=-1, inputType="text") {
    curValue = (!curValue) ? "" : curValue; // `null` values converted to empty string
    var maxlength = "", maxLenAttr = "", overflowClass = "";
    if(this.maxlengthData && !!this.maxlengthData[dataKey]) {
      maxlength = `data-maxlngth="${this.maxlengthData[dataKey]}"`;    // get maxlength from json form config // turn to maxlength to actually clamp textfield inputs
      maxLenAttr = `data-maxlength="${curValue.length} / ${this.maxlengthData[dataKey]}"`;
      overflowClass = (curValue.length >= this.maxlengthData[dataKey]) ? `class="overflow"` : "";
    }
    return (index == -1) ?                // build open tag whether it's a config or slide data property
      `<label for="config-${dataKey}" ${maxLenAttr} ${overflowClass}>${label}</label>
       <input type="${inputType}" id="config-${dataKey}" data-config-key="${dataKey}" value="${curValue}" ${maxlength} />`
       :
      `<label for="slide-${dataKey}-${index}" ${maxLenAttr} ${overflowClass}>${label}</label>
       <input type="${inputType}" id="slide-${dataKey}-${index}" data-slide-index="${index}" data-slide-key="${dataKey}" value="${curValue}" ${maxlength} />`;
  }

  buildTextarea(label, dataKey, curValue, index=-1) {
    curValue = (!curValue) ? "" : curValue; // `null` values converted to empty string
    var maxlength = "", maxLenAttr = "", overflowClass = "";
    if(this.maxlengthData && !!this.maxlengthData[dataKey]) {
      maxlength = `data-maxlngth="${this.maxlengthData[dataKey]}"`;    // get maxlength from json form config // turn to maxlength to actually clamp textfield inputs
      maxLenAttr = `data-maxlength="${curValue.length} / ${this.maxlengthData[dataKey]}"`;
      overflowClass = (curValue.length >= this.maxlengthData[dataKey]) ? `class="overflow"` : "";
    }
    return (index == -1) ?                // build open tag whether it's a config or slide data property
      `<label for="config-${dataKey}" ${maxLenAttr} ${overflowClass}>${label}</label>
       <textarea id="config-${dataKey}" data-config-key="${dataKey}" ${maxlength}>${curValue}</textarea>`
       :
      `<label for="slide-${dataKey}-${index}" ${maxLenAttr} ${overflowClass}>${label}</label>
       <textarea id="slide-${dataKey}-${index}" data-slide-index="${index}" data-slide-key="${dataKey}" ${maxlength}>${curValue}</textarea>`;
  }

  formTextUpdated(e) {
    if(e.target) {
      let inputEl = e.target;
      let nodeName = inputEl.nodeName.toLowerCase();
      let isTextInput = (nodeName == 'input' && inputEl.getAttribute("type") == "text");
      let isNumberInput = (nodeName == 'input' && inputEl.getAttribute("type") == "number");
      if(isTextInput || isNumberInput || nodeName == 'textarea') {
        if(isNumberInput) this.forceNumeric(inputEl);
        this.textUpdated(inputEl);
      }
    }
  }

  forceNumeric(inputEl) {
    // if non-numeric, input value is empty, so we can set it to zero as a default
    if(inputEl.value.length == 0) inputEl.value = 0;
  }

  textUpdated(inputEl) {
    // update maxlength via label attribute, since text inputs can't have pseudo-elements
    let inputId = inputEl.getAttribute('id');
    let labelForInput = this.form.querySelector(`label[for="${inputId}"]`);
    if(labelForInput && inputEl.hasAttribute('data-maxlngth')) {  // turn to maxlength to actually clamp textfield inputs
      let maxLen = inputEl.getAttribute('data-maxlngth'); // turn to maxlength to actually clamp textfield inputs
      let curLen = inputEl.value.length;
      labelForInput.setAttribute('data-maxlength', `${curLen} / ${maxLen}`);  // <span class="curLen">${curLen}</span> / <span class="maxLen">${maxLen}</span>
      if(curLen >= maxLen) {
        labelForInput.classList.add("overflow");
      } else {
        labelForInput.classList.remove("overflow");
      }
    }
    // grab value to be updated on json obj
    var savedVal = inputEl.value.trim();
    // update config data on json data object as we type
    if(inputEl.hasAttribute('data-config-key')) {
      let configKey = inputEl.getAttribute('data-config-key');
      this.configData[configKey] = savedVal;
    }
    // update slide data on json data object - get slide index to target the slide
    // and use the 'data-slide-key' attribute to target data on the main slides data object
    if(inputEl.hasAttribute('data-slide-key')) {
      let slideDataKey = inputEl.getAttribute('data-slide-key');
      let slideIndex = parseInt(inputEl.getAttribute('data-slide-index'));
      this.slidesData[slideIndex][slideDataKey] = savedVal;
    }
  }

  // block ENTER from submitting form

  formKeyDown(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'input') {
      if(e.keyCode == 13) e.preventDefault();
    }
  }

  //////////////////////
  // LOAD FORM DATA
  //////////////////////

  // load list of uploads for dropdown

  loadAssetsData() {
    // send request
    fetch(this.assetsListPath, {
      method: 'POST',
      body: JSON.stringify({})
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);  // get response
        this.assetsList = data;
        requestAnimationFrame(() => this.loadFormData());
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, 'Assets list fetch failed: ' + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

  // load current data to build form

  loadFormData() {
    // send request
    fetch(this.formDataPath, {
      method: 'POST',
      body: JSON.stringify({})
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        this.setFormDataFromServer(JSON.parse(data)); // store response
        _store.set(SimpleSite.LOADER_SHOW, false);
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, 'Slides data fetch failed: ' + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

  setFormDataFromServer(jsonData) {
    // store local properties of form json
    for(var key in jsonData) {
      this[key+"Data"] = jsonData[key];
    }
    requestAnimationFrame(() => this.rebuildForm());
  }

  // convert paths between static sites in /apps/ and CMS pointing to the same assets on the server

  valIsString(val) {
    return typeof val === 'string' || val instanceof String;
  }

  prepAssetsForCMS() {
    // replace `../_uploads` with `app/_uploads` to switch from static site's to CMS's asset path reference
    if(this.slidesData) this.slidesData.forEach((slide, i) => {
      for(var key in slide) {
        if(this.valIsString(slide[key])) slide[key] = slide[key].replace("../_uploads", "apps/_uploads");
      }
    });
    if(this.configData) for(var key in this.configData) {
      if(this.valIsString(this.configData[key])) {
        this.configData[key] = this.configData[key].replace("../_uploads", "apps/_uploads");
      }
    }
  }

  prepAssetsForSubmit() {
    // replace `app/_uploads` with `../_uploads` to switch from CMS's to static site's asset path reference
    if(this.slidesData) this.slidesData.forEach((slide, i) => {
      for(var key in slide) {
        if(this.valIsString(slide[key])) slide[key] = slide[key].replace("apps/_uploads", "../_uploads");
      }
    });
    if(this.configData) for(var key in this.configData) {
      if(this.valIsString(this.configData[key])) {
        this.configData[key] = this.configData[key].replace("apps/_uploads", "../_uploads");
      }
    }
  }

  //////////////////////////
  // BUILD FORM
  //////////////////////////
  // build form sections from json form data
  // needs to be overridden by subclass

  rebuildForm() {
    this.prepAssetsForCMS();
    this.formContainer.innerHTML = this.buildConfig() + this.buildSlides();
  }

  buildConfig() {
    return ""; // override if there's an app config form section (Boulders & Pylons)
  }

  buildSlides() {
    return ""; // override if there's an app config form section (Boulders & Pylons)
  }

  /////////////////////////
  // SLIDE BUTTON ACTIONS
  /////////////////////////

  handleSlideActions(buttonEl, slideIndex, slideAction) {
    // TODO: make handleSlideActions() extensible by subclass?
    switch(slideAction) {
      case "move-up" :
        if(slideIndex > 0) {
          let removedSlide = this.slidesData.splice(slideIndex, 1);
          this.slidesData.splice(slideIndex - 1, 0, removedSlide[0]);
          this.rebuildForm();
        } else {
          _store.set(SimpleSite.ALERT_ERROR, "Can't move up");
        }
        break;
      case "move-down" :
        if(slideIndex < this.slidesData.length - 1) {
          let removedSlide = this.slidesData.splice(slideIndex, 1);
          this.slidesData.splice(slideIndex + 1, 0, removedSlide[0]);
          this.rebuildForm();
        } else {
          _store.set(SimpleSite.ALERT_ERROR, "Can't move down");
        }
        break;
      case "slide-delete" :
        if(this.slidesData.length > 1) {
          if(confirm("Are you sure you want to delete this item?") == true) {
            let removedSlide = this.slidesData.splice(slideIndex, 1);
            this.rebuildForm();
          }
        } else {
          _store.set(SimpleSite.ALERT_ERROR, "Can't delete the only item");
        }
        break;
      // DEMO DESK ------------
      case "copy-slide" :
        let curSlide = this.slidesData[slideIndex];
        let copySlide = {};
        for(var key in curSlide) copySlide[key] = curSlide[key];
        this.slidesData.splice(slideIndex + 1, 0, copySlide);
        this.rebuildForm();
        break;
      // PYLON ----------------
      case "add-text-slide" :
        let newTextSlide = {descriptionEN: "", descriptionES: ""};
        this.slidesData.splice(slideIndex + 1, 0, newTextSlide);
        this.rebuildForm();
        break;
      case "add-video-slide" :
        let defaultVideoSelection = (this.assetsList && this.assetsList.length > 0) ? this.assetsList[0].filePath : "No Videos Uploaded";
        let newVideoSlide = {assetURL: defaultVideoSelection};
        this.slidesData.splice(slideIndex + 1, 0, newVideoSlide);
        this.rebuildForm();
        break;
      case "add-credits-slide" :
        let newCreditsSlide = {creditsTitleEN: "", creditsEN: "", creditsTitleES: "", creditsES: ""};
        this.slidesData.splice(slideIndex + 1, 0, newCreditsSlide);
        this.rebuildForm();
        break;
      default: break;
    }
  }

  /////////////////////////
  // POST FORM DATA TO SERVER
  /////////////////////////

  handlePublishActions(buttonEl) {
    // save draft json data
    if(buttonEl.hasAttribute('data-form-submit')) {
      this.submitForm();
    }
    // special publish button to copy app config to static files
    else if(buttonEl.hasAttribute('data-form-publish')) {
      this.publishData();
    } else if(buttonEl.hasAttribute('data-form-reset-from-publish')) {
      this.resetData();
    }
  }

  submitForm() {
    // prep data object with relative paths for static site
    this.prepAssetsForSubmit();
    _store.set(SimpleSite.LOADER_SHOW, true);

    // create data object from active app data
    // dynamically include config data, since it might not exist for some apps (demodesk)
    let postData = {};
    if(this.slidesData) postData.slides = this.slidesData;
    if(this.configData) postData.config = this.configData;

    // send request
    fetch(this.form.getAttribute('action'), {
      method: 'POST',
      body: JSON.stringify(postData)
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);  // get response
        if(data.success) {
          _store.set(SimpleSite.ALERT_SUCCESS, data.success);
          _store.set(SimpleSite.RELOAD_VIEW, true);   // reload form if we've published the data
        } else {
          _store.set(SimpleSite.ALERT_ERROR, data.fail);
        }
        _store.set(SimpleSite.LOADER_SHOW, false);
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, 'Fetch failed: ' + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

  // publish draft data to SciPy

  publishData() {
    if(!confirm("Are you sure you want to publish this data to the SciPy?")) return;

    // prep submit & send request
    _store.set(SimpleSite.LOADER_SHOW, true);
    fetch(this.form.getAttribute('action').replace("update", "publish"), {  // convert /update to /publish, piggybacking on existing config form API paths
      method: 'POST',
      body: JSON.stringify({})
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);  // get response
        if(data.success) {
          _store.set(SimpleSite.ALERT_SUCCESS, data.success);
          _store.set(SimpleSite.RELOAD_VIEW, true);   // reload form if we've published the data
        } else {
          _store.set(SimpleSite.ALERT_ERROR, data.fail);
        }
        _store.set(SimpleSite.LOADER_SHOW, false);
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, 'Publish fetch failed: ' + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

  // reset draft data from latest static app version

  resetData() {
    if(!confirm("Are you sure you want to reset the data to the last publish?")) return;

    // send request
    fetch(this.form.getAttribute('action').replace("update", "reset"), {  // convert /update to /publish, piggybacking on existing config form API paths
      method: 'POST',
      body: JSON.stringify({})
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);  // get response
        if(data.success) {
          _store.set(SimpleSite.ALERT_SUCCESS, data.success);
          _store.set(SimpleSite.RELOAD_VIEW, true);   // reload form if we've reset the data
        } else {
          _store.set(SimpleSite.ALERT_ERROR, data.fail);
        }
        _store.set(SimpleSite.LOADER_SHOW, false);
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, 'Fetch failed: ' + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

  /////////////////////////////////
  // CLEAN UP
  /////////////////////////////////

  dispose() {
    super.dispose();
    this.el.removeEventListener('click', this.formClickHandler);
    this.el.removeEventListener('input', this.formSelectHandler);
    this.el.removeEventListener('input', this.formCheckboxHandler);
    this.form.removeEventListener('input', this.formTextUpdatedHandler);
    this.form.removeEventListener('keydown', this.formEnterSubmitBlocker);
	}

}

window.JsonEditorView = JsonEditorView;

class ConfigFormView extends JsonEditorView {

  constructor(el) {
    super(el);
	}

  // custom form build overrides

  buildConfig() {
    let configFormHTML = `
      <p class="grid-container quarters">
        <a class="button button-primary" href="javascript:window.history.back();">&larr; Back</a>
      </p>
      <h2>Config</h2>
      <div class="json-editor-config-props grid-container halves">
    `;
    for(var key in this.configData) {
      let value = this.configData[key];
      configFormHTML += this.configTemplate(key, value);
    }
    configFormHTML += "</div>";
    return configFormHTML;
  }

  // custom app data cards

  inputForData(key, value, label) {
    let dataType = typeof(value);
    var inputHtml = "";
    switch(dataType) {
      case "string" :
        // todo: check for hex color
        inputHtml = this.buildTextInput(label, key, value);
        break;
      case "number" :
        inputHtml = this.buildTextInput(label, key, value, -1, 'number');
        break;
      case "boolean" :
        inputHtml = this.buildCheckbox(label, key, value);
        break;
    }
    return inputHtml;
  }

  configTemplate(key, value) {
    let label = (this.labelsData && this.labelsData[key]) ? this.labelsData[key] : key;
    let inputEl = this.inputForData(key, value, label);
    let configCard = `
      <div class="config-card">
        ${inputEl}
      </div>
    `;
    return configCard;
  }

}

window.ConfigFormView = ConfigFormView;

class DemoDeskFormView extends JsonEditorView {

  constructor(el) {
    super(el);
  }

  // custom form build overrides

  buildSlides() {
    let slidesHTML = '<h2>Slides</h2>';
    slidesHTML += '<div>';
    this.slidesData.forEach((slide, i) => {
      slidesHTML += this.slideTemplate(slide, i);
    });
    slidesHTML += "</div>";
    return slidesHTML;
  }

  // custom app data cards

  slideTemplate(slide, index) {
    return `
      <h5>Slide #${index+1}</h5>
      <div class="json-editor-slide grid-container thirds">
        <div>
          ${this.buildMediaDropdown("Slide Background:", "assetURL", slide.assetURL, null, index)}
          <div class="json-editor-asset-preview">${this.mediaNodeFromAsset(slide.assetURL)}</div>
        </div>
        <div>
          ${this.buildCheckbox("Hide Footer:", "hideFooter", slide.hideFooter, index)}
          <div>${this.buildTextInput("Text line 1", "textLine1", slide.textLine1, index)}</div>
          <div>${this.buildTextInput("Text line 2", "textLine2", slide.textLine2, index)}</div>
        </div>
        <div class="json-editor-slide-actions">
          <label>Actions:</label>
          <button data-slide-index="${index}" data-slide-action="move-up">Move Up &uarr;</button>
          <button data-slide-index="${index}" data-slide-action="move-down">Move Down &darr;</button>
          <button data-slide-index="${index}" data-slide-action="slide-delete">Delete</button>
          <button data-slide-index="${index}" data-slide-action="copy-slide">Copy Slide</button>
        </div>
        <div>
          <div>${this.buildTextarea("Text Paragraph (EN)", "textParagraphEN", slide.textParagraphEN, index)}</div>
        </div>
        <div>
          <div>${this.buildTextarea("Text Paragraph (ES)", "textParagraphES", slide.textParagraphES, index)}</div>
        </div>
      </div>
    `;
  }

}

window.DemoDeskFormView = DemoDeskFormView;

class LoginView extends BaseSiteView {

  constructor(el) {
    super(el);
    this.loginForm = this.el.querySelector('#login-form');
    if(this.loginForm) this.initLogin();
    document.body.classList.add('logged-out');
	}

  initLogin() {
     {
      this.loginHandler = this.formSubmitted.bind(this);
      this.loginForm.addEventListener('submit', this.loginHandler);
    }
  }

  formSubmitted(e) {
    e.preventDefault();

    // reset form
    this.loginForm.classList.remove('error');
    _store.set(SimpleSite.LOADER_SHOW, true);

    // grab form data & build post object
    let passwordInputEl = this.loginForm.querySelector('#password');
    let userPasswordVal = passwordInputEl.value;
    let userPasswordKey = passwordInputEl.getAttribute('name');
    let bodyObj = {};
    bodyObj[userPasswordKey] = userPasswordVal;

    // submit request
    fetch(this.loginForm.getAttribute('action'), {
      method: this.loginForm.getAttribute('method'),
      body: JSON.stringify(bodyObj)
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);
        let success = data.success;
        if(success) {
          let curPath = _store.get(SimpleSite.CUR_PATH);
          if(curPath == '/login') {
            _store.set(SimpleSite.SET_CUR_PATH, '/');     // go home from generic /login
          } else {
            _store.set(SimpleSite.RELOAD_VIEW, true);     // reload the protected page
          }
          document.body.classList.remove('logged-out');
        } else {
          this.loginForm.classList.add('error');
        }
        _store.set(SimpleSite.LOADER_SHOW, false);
      }).catch(function(ex) {
        alert('Fetch failed ' + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

}

window.LoginView = LoginView;

class ScheduleView extends BaseSiteView {

  constructor(el) {
    super(el);
    requestAnimationFrame(() => {
      this.isSchedule = _store.get(SimpleSite.CUR_PATH) == "/schedule"; // do slightly different things between events/schedule
      this.initScheduleForm();
    });
	}

  initScheduleForm() {
    this.scheduleTextForm = this.el.querySelector('form');
    if(this.scheduleTextForm) {
      this.scheduleHandler = this.scheduleFormSubmitted.bind(this);
      // this.scheduleTextForm.addEventListener('submit', this.scheduleHandler);
      this.scheduleTextForm.addEventListener('click', this.scheduleHandler);
    }
  }

  scheduleFormSubmitted(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'button') {
      if(e.target.hasAttribute('type') && e.target.getAttribute('type') == 'submit') {
        e.preventDefault();
        this.checkDeleteClick(e.target);
        this.submitScheduleForm();
      }
    }
  }

  checkDeleteClick(buttonEl) {
    if(buttonEl.hasAttribute('data-action') && buttonEl.getAttribute('data-action') == 'delete') {
      let parentRow = buttonEl.closest('.row');
      if(parentRow) {
        parentRow.remove();
        // parentRow.parentNode.removeChild(parentRow);
      }
    }
  }

  dateToComparableString(dateObj) {
    let monthInt = parseInt(dateObj.month);
    let dayInt = parseInt(dateObj.day);
    let hourInt = parseFloat(dateObj.timeStart);
    let paddedMonth = (monthInt < 10) ? "0" + monthInt : monthInt;
    let paddedDay = (dayInt < 10) ? "0" + dayInt : dayInt;
    let paddedHour = (hourInt < 10) ? "0" + hourInt : hourInt;
    let compareStr = paddedMonth + '-' + paddedDay + '-' + paddedHour;
    return compareStr;
  }

  submitScheduleForm() {
    document.body.classList.add('data-loading');

    // grad date/title rows
    let dateTitleEntries = this.scheduleTextForm.querySelectorAll('.row');
    let updateObj = {};
    updateObj['dates'] = [];
    dateTitleEntries.forEach((rowEl, i) => {
      let titleVal = rowEl.querySelector('[data-type=title]').value.trim();
      if(titleVal.length > 0 || this.isSchedule == true) {
        let dataRowObj = {};
        dataRowObj['title'] = titleVal.replace(/'/g, "’"); // replace apostrophe inline
        if(rowEl.querySelector('[data-type=month]')) dataRowObj['month'] = rowEl.querySelector('[data-type=month]').value;
        if(rowEl.querySelector('[data-type=day]')) dataRowObj['day'] = rowEl.querySelector('[data-type=day]').value;
        if(rowEl.querySelector('[data-type=timeStart]')) dataRowObj['timeStart'] = rowEl.querySelector('[data-type=timeStart]').value;
        if(rowEl.querySelector('[data-type=timeEnd]')) dataRowObj['timeEnd'] = rowEl.querySelector('[data-type=timeEnd]').value;
        updateObj['dates'].push(dataRowObj);
      }
    });

    // sort on date
    updateObj['dates'].sort((a, b) => {
      let x = this.dateToComparableString(a);
      let y = this.dateToComparableString(b);
      if (x < y) {return -1;}
      if (x > y) {return 1;}
      return 0;
    })

    // send to server
    fetch(this.scheduleTextForm.getAttribute('action'), {
      method: this.scheduleTextForm.getAttribute('method'),
      body: JSON.stringify(updateObj)
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);
        let success = data.success;
        if(this.isSchedule == false) _store.set(SimpleSite.SET_CUR_PATH, '/events'); // reload page on /events
        if(success) {
          // alert('success');
        } else {
          // this.loginForm.classList.add('error');
        }
        document.body.classList.remove('data-loading');
      }).catch(function(ex) {
        alert('Fetch failed ' + ex.message);
        document.body.classList.remove('data-loading');
      });
  }

  dispose() {
    super.dispose();
    // if(this.scheduleTextForm) this.scheduleTextForm.removeEventListener('submit', this.scheduleHandler);
    if(this.scheduleTextForm) this.scheduleTextForm.removeEventListener('click', this.scheduleHandler);
	}

}

window.ScheduleView = ScheduleView;

class UploadView extends BaseSiteView {

  constructor(el) {
    super(el);
    this.uploadForm = this.el.querySelector('#upload-form');
    this.formResultEl = this.el.querySelector('#upload-form-result');
    this.inputEl = this.uploadForm.querySelector('input[type="file"]');
    this.uploadsEl = this.el.querySelector("#uploads-container");
    this.initImageUploadForm();
    this.listenForDeleteClick();
    this.displayAllUploads();
	}

  /////////////////
  // IMAGE UPLOAD FORM
  /////////////////

  initImageUploadForm() {
    if(this.uploadForm) {
      // form submit override listener
      this.fileUploadHandler = this.uploadFormSubmitted.bind(this);
      this.uploadForm.addEventListener('submit', this.fileUploadHandler);
      // file input select listener
      this.fileChangeHandler = this.fileSelected.bind(this);
      this.uploadForm.addEventListener('change', this.fileChangeHandler);
      // drag & drop file onto form listeners for css styling
      this.formDragOverHandler = this.formDragFileOver.bind(this);
      this.uploadForm.addEventListener('dragover', this.formDragOverHandler);
      this.formDragLeaveHandler = this.formDragFileLeave.bind(this);
      this.uploadForm.addEventListener('dragleave', this.formDragLeaveHandler);
      this.formDropFileHandler = this.formDropFile.bind(this);
      this.uploadForm.addEventListener('drop', this.formDropFileHandler);
    }
  }

  // drag & drop -----

  formDragFileOver(e) {
    e.preventDefault();
    this.uploadForm.classList.add('drop-over');
  }

  formDragFileLeave(e) {
    // e.preventDefault();
    this.uploadForm.classList.remove('drop-over');
  }

  formDropFile(e) {
    e.preventDefault();
    this.uploadForm.classList.remove('drop-over');

    // get files from drop
    let files = e.target.files || e.dataTransfer.files;  // get files array from drop event
    this.inputEl.files = files;                           // set dropped files on file input
    this.fileSelected({target:this.inputEl});            // simulate input change event to trigger preview
  }

  // image selected listener for input

  fileSelected(e) {
    if(e.target && e.target.files && e.target.files.length > 0) {
      let isVideo = (e.target.files[0].name.match(/.mp4/)) ? true : false;
      let mediaBlob = URL.createObjectURL(e.target.files[0]);
      let previewImg = this.el.querySelector('#img-preview');
      let previewVideo = this.el.querySelector('#video-preview');
      if(isVideo) {
        previewVideo.src = mediaBlob;
        previewImg.removeAttribute('src');
      } else {
        previewImg.src = mediaBlob;
        previewVideo.removeAttribute('src');
      }
      this.clearFormResult();
    } else {
      this.formResultError("Couldn't load file");
    }
  }

  clearPreview() {
    let previewImg = this.el.querySelector('#img-preview');
    let previewVideo = this.el.querySelector('#video-preview');
    previewImg.removeAttribute('src');
    previewVideo.removeAttribute('src');
  }

  uploadFormSubmitted(e) {
    e.preventDefault();
    this.submitFileUploadForm();
  }

  submitFileUploadForm() {
    // validate selected file
    if(!this.inputEl.files || this.inputEl.files.length == 0) {
      this.formResultError("Please select an image or video to upload");
      return;
    }

    // reset loading
    _store.set(SimpleSite.LOADER_SHOW, true);
    this.clearFormResult();

    // prep file file upload data
    var data = new FormData();
    data.append('file_upload', this.inputEl.files[0]);

    // send to server
    fetch(this.uploadForm.getAttribute('action'), {
      method: this.uploadForm.getAttribute('method'),
      body: data
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);
        if(data.success) {
          this.formResultSuccess(data.success);
          _store.set(SimpleSite.ALERT_SUCCESS, "Upload success!");
          requestAnimationFrame(() => {this.displayAllUploads()});
        } else if(data.fail) {
          this.formResultError(data.fail);
        }
        _store.set(SimpleSite.LOADER_SHOW, false);
        this.uploadForm.reset();
        this.clearPreview();
      }).catch((ex) => {
        this.formResultError("Fetch js upload failed: " + ex.message);
        _store.set(SimpleSite.LOADER_SHOW, false);
        this.uploadForm.reset();
        this.clearPreview();
      });
  }

  clearFormResult() {
    this.formResultEl.innerHTML = '';
  }

  formResultSuccess(msg) {
    this.formResultEl.innerHTML = msg;
  }

  formResultError(msg) {
    this.formResultEl.innerHTML = '<span class="form-upload-error-message">'+ msg +'</span>';
  }

  /////////////////
  // LOAD UPLOADS FRAGMENT
  /////////////////

  displayAllUploads() {
    fetch(this.uploadForm.getAttribute('data-uploads'), {method: "POST"})
      .then(function(response) {
        return response.text();
      }).then((data) => {
        this.uploadsEl.innerHTML = data;
        this.removeImageZooming();
        this.addImageZooming()
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, "Couldn't load uploads");
      });
  }

  /////////////////
  // DELETE IMAGES
  /////////////////

  listenForDeleteClick() {
    this.deleteClickHandler = this.deleteButtonClicked.bind(this);
    this.uploadsEl.addEventListener('click', this.deleteClickHandler);
  }

  deleteButtonClicked(e) {
    if(e.target && e.target.nodeName.toLowerCase() == 'button') {
      if(e.target.hasAttribute('data-action')) {
        e.preventDefault();
        let buttonAction = e.target.getAttribute('data-action');
        if(buttonAction == "delete") {
          var confirmResult = confirm("Are you sure you want to delete this file?");
          if(confirmResult == true) {
           this.deleteImage(e.target);
          } else {
           // canceled
          }
        }
      }
    }
  }

  deleteImage(button) {
    _store.set(SimpleSite.LOADER_SHOW, true);

    // set post data specifying the upload to delete
    let filePath = button.getAttribute('data-upload-path');
    let uploadData = {'filepath': filePath};

    fetch(this.uploadForm.getAttribute('data-delete'), {
      method: 'post',
      body: JSON.stringify(uploadData)
    })
      .then(function(response) {
        return response.text();
      }).then((data) => {
        data = JSON.parse(data);
        this.clearFormResult();
        this.displayAllUploads();
        _store.set(SimpleSite.ALERT_SUCCESS, "File deleted!");
        _store.set(SimpleSite.LOADER_SHOW, false);
      }).catch(function(ex) {
        _store.set(SimpleSite.ALERT_ERROR, "Delete request failed");
        _store.set(SimpleSite.LOADER_SHOW, false);
      });
  }

  // CLEANUP

  dispose() {
    super.dispose();
    if(this.uploadForm) {
      this.uploadForm.removeEventListener('submit', this.fileUploadHandler);
      this.uploadForm.removeEventListener('change', this.fileChangeHandler);
      this.uploadForm.removeEventListener('dragover', this.formDragOverHandler);
      this.uploadForm.removeEventListener('dragleave', this.formDragLeaveHandler);
      this.uploadForm.removeEventListener('drop', this.formDropFileHandler);
    }
    this.uploadsEl.removeEventListener('click', this.deleteClickHandler);
	}

}

window.UploadView = UploadView;


(function(){

  window.embetter = {};
  var embetter = window.embetter;

  /////////////////////////////////////////////////////////////
  // COMMON UTIL HELPERS
  /////////////////////////////////////////////////////////////

  embetter.debug = true;
  embetter.curEmbeds = [];
  embetter.mobileScrollTimeout = null;
  embetter.mobileScrollSetup = false;
  embetter.apiEnabled = false;
  embetter.apiAutoplayCallback = null;
  embetter.defaultThumbnail = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArwAAAGcAQMAAAABMOGrAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAADUExURQAAAKd6PdoAAAA6SURBVHja7cGBAAAAAMOg+VPf4ARVAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAN488AAGP4e1mAAAAAElFTkSuQmCC';

  embetter.utils = {
    /////////////////////////////////////////////////////////////
    // REGEX HELPERS
    /////////////////////////////////////////////////////////////
    buildRegex: function(regexStr) {
      var optionalPrefix = '(?:https?:\\/\\/)?(?:w{3}\\.)?';
      var terminator = '(?:\\/?|$|\\s|\\?|#)';
      return new RegExp(optionalPrefix + regexStr + terminator);
    },
    /////////////////////////////////////////////////////////////
    // BUILD HTML TEMPLATES
    /////////////////////////////////////////////////////////////
    stringToDomElement: function(str) {
      var div = document.createElement('div');
      div.innerHTML = str;
      return div.firstChild;
    },
    playerHTML: function(service, mediaUrl, thumbnail, id) {
      return '<div class="embetter" ' + service.dataAttribute + '="' + id + '">\
          <a href="' + mediaUrl + '" target="_blank"><img src="' + thumbnail + '"></a>\
        </div>';
    },
    isMobile: (function() {
      return navigator.userAgent.toLowerCase().match(/iphone|ipad|ipod|android/) ? true : false;
    })(),
    matches: (function() {
      var b = document.createElement('div');
      return b.matches || b.webkitMatchesSelector || b.mozMatchesSelector || b.msMatchesSelector;
    })(),
    parentSelector: function(node, selector) {
      if (this.matches.bind(node)(selector)) {
        return node;
      }
      node = node.parentNode;
      while (node && node !== document) {
        if (this.matches.bind(node)(selector)) {
          return node;
        } else {
          node = node.parentNode;
        }
      }
      return false;
    },

    /////////////////////////////////////////////////////////////
    // MEDIA PLAYERS PAGE MANAGEMENT
    /////////////////////////////////////////////////////////////
    initMediaPlayers: function(el, services) {
      for (var i = 0; i < services.length; i++) {
        var service = services[i];
        var serviceEmbedContainers = el.querySelectorAll('div['+service.dataAttribute+']');
        for(var j=0; j < serviceEmbedContainers.length; j++) {
          embetter.utils.initPlayer(serviceEmbedContainers[j], service);
        }
      }
      // handle mobile auto-embed on scroll
      if(embetter.utils.isMobile && embetter.mobileScrollSetup == false) {
        window.addEventListener('scroll', embetter.utils.scrollListener);
        embetter.mobileScrollSetup = true;
        // force scroll to trigger listener on page load
        window.scroll(window.scrollX, window.scrollY+1);
        window.scroll(window.scrollX, window.scrollY-1);
      };
    },
    scrollListener: function() {
      // throttled scroll listener
      if(embetter.mobileScrollTimeout != null) {
        window.clearTimeout(embetter.mobileScrollTimeout);
      }
      // check to see if embeds are on screen. if so, embed! otherwise, unembed
      // exclude codepen since we don't know what might execute
      embetter.mobileScrollTimeout = setTimeout(function() {
        for (var i = 0; i < embetter.curEmbeds.length; i++) {
          var player = embetter.curEmbeds[i];
          var playerRect = player.el.getBoundingClientRect();
          if(playerRect.top < window.innerHeight && playerRect.bottom > 0) {
            if(player.getType() !== 'codepen') { // && player.getType() != 'gif'
              player.embedMedia(false);
            }
          } else {
            player.unembedMedia();
          }
        };
      }, 500);
    },
    initPlayer: function(embedEl, service) {
      if(embedEl.classList.contains('embetter-ready') == true) return;
      if(embedEl.classList.contains('embetter-static') == true) return;
      embetter.curEmbeds.push( new embetter.EmbetterPlayer(embedEl, service) );
    },
    unembedPlayers: function(containerEl) {
      for (var i = 0; i < embetter.curEmbeds.length; i++) {
        if(containerEl && containerEl.contains(embetter.curEmbeds[i].el)) {
          embetter.curEmbeds[i].unembedMedia();
        }
      };
    },
    disposePlayers: function() {
      for (var i = 0; i < embetter.curEmbeds.length; i++) {
        embetter.curEmbeds[i].dispose();
      }
      window.removeEventListener('scroll', embetter.utils.scrollListener);
      embetter.mobileScrollSetup = false;
      embetter.curEmbeds.splice(0, embetter.curEmbeds.length-1);
    },
    mediaComplete: function() {
      if(embetter.curPlayer !== null) {
        var playerEl = embetter.curPlayer.el;
        var playlistContainer = this.parentSelector(playerEl, '[data-embetter-playlist]');  // check if we're in a playlist container
        if(playlistContainer) {
          var playlistPlayerEls = playlistContainer.querySelectorAll('.embetter');
          for(var i=0; i < playlistPlayerEls.length - 1; i++) { // skip the last one, since there's nothing else to play
            if(playlistPlayerEls[i].classList.contains('embetter-playing')) { // find the active player and tell the next one to play
              var nextPlayerObj = embetter.utils.getPlayerFromEl(playlistPlayerEls[i+1]);
              if(nextPlayerObj) {
                nextPlayerObj.play();
                if(embetter.apiAutoplayCallback) embetter.apiAutoplayCallback(nextPlayerObj.el);
              }
              break;
            }
          }
        }
      }
    },
    getPlayerFromEl: function(el) {
      for (var i=0; i < embetter.curEmbeds.length; i++) {
        if(el === embetter.curEmbeds[i].el) {
          return embetter.curEmbeds[i];
        }
      }
      return null;
    },
    disposeDetachedPlayers: function() {
      // dispose any players no longer in the DOM
      for (var i = embetter.curEmbeds.length - 1; i >= 0; i--) {
        var embed = embetter.curEmbeds[i];
        if(document.body.contains(embed.el) === false || embed.el === null) {
          embed.dispose();
          delete embetter.curEmbeds.splice(i,1);
        }
      }
    },
    loadRemoteScript: function(scriptURL) {
      var tag = document.createElement('script');
      tag.src = scriptURL;
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }
  };


  /////////////////////////////////////////////////////////////
  // 3RD-PARTY SERVICE SUPPORT
  /////////////////////////////////////////////////////////////

  embetter.services = {};

  /////////////////////////////////////////////////////////////
  // NATIVE VIDEO
  /////////////////////////////////////////////////////////////
  embetter.services.video = {
    type: 'video',
    dataAttribute: 'data-video-url',
    regex: embetter.utils.buildRegex('(.mp4|.mov|.m4v)'),
    embed: function(id, w, h, autoplay, poster) {
      var autoplayAttr = (autoplay == true) ? ' autoplay="true" ' : '';
      return '<video id="' + id + '" src="'+ id + '" poster="'+ poster + '" '+ autoplayAttr +' width="'+ w +'" height="'+ h +'" controls="true" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
    },
  };

  /////////////////////////////////////////////////////////////
  // GIF FILE
  /////////////////////////////////////////////////////////////
  embetter.services.gif = {
    type: 'gif',
    dataAttribute: 'data-gif-url',
    regex: embetter.utils.buildRegex('.gif'),
    embed: function(id, w, h, autoplay, poster) {
      return '<img class="gif" id="' + id + '" src="'+ id + '" width="'+ w +'" height="'+ h +'">';
    },
  };

  /////////////////////////////////////////////////////////////
  // YOUTUBE
  // http://stackoverflow.com/questions/2068344/how-do-i-get-a-youtube-video-thumbnail-from-the-youtube-api
  // https://developers.google.com/youtube/iframe_api_reference
  // http://stackoverflow.com/questions/3717115/regular-expression-for-youtube-links
  /////////////////////////////////////////////////////////////
  embetter.services.youtube = {
    type: 'youtube',
    dataAttribute: 'data-youtube-id',
    regex: /(?:.+?)?(?:youtube\.com\/v\/|watch\/|\?v=|\&v=|youtu\.be\/|\/v=|^youtu\.be\/)([a-zA-Z0-9_-]{11})+/,
    embed: function(id, w, h, autoplay, poster) {
      var autoplayQuery = (autoplay === true) ? '&autoplay=1' : '';
      return '<iframe class="video" enablejsapi="1" width="'+ w +'" height="'+ h +'" src="https://www.youtube.com/embed/'+ id +'?rel=0&suggestedQuality=hd720&enablejsapi=1'+ autoplayQuery +'" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'https://www.youtube.com/watch?v=' + id;
    },
    loadAPI: function(apiLoadedCallback) {
      var self = this;
      if(typeof window.onYouTubeIframeAPIReady !== 'undefined') {
        apiLoadedCallback();
        self.activateCurrentPlayer();
        return;
      }
      // docs here: https://developers.google.com/youtube/iframe_api_reference
      // requires enablejsapi above to connect to an existing iframe
      // load the IFrame Player API code asynchronously.
      embetter.utils.loadRemoteScript("https://www.youtube.com/iframe_api");
      // creates an <iframe> (and YouTube player) after the API code downloads.
      function onYouTubeIframeAPIReady() {
        apiLoadedCallback();
        self.activateCurrentPlayer();
      }
      window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
    },
    activateCurrentPlayer: function() {
      this.currentIframe = document.querySelector('.embetter-playing[data-youtube-id] iframe');
      this.currentIframe.id = document.querySelector('.embetter-playing').getAttribute('data-youtube-id'); // set the id on the iframe
      if (this.currentIframe.id) {
        this.apiPlayer = new YT.Player(this.currentIframe.id, {
          events: {
            'onReady': function() {},
            'onPlaybackQualityChange': function() {},
            'onError': function() {
              embetter.utils.mediaComplete();
            },
            'onStateChange': function(e) {
              /* -1 (unstarted) | 0 (ended) | 1 (playing) | 2 (paused) | 3 (buffering) | 5 (video cued) */
              if(e.data == 0) {
                embetter.utils.mediaComplete();
              }
            }
          }
        });
      }
    }
  };


  /////////////////////////////////////////////////////////////
  // VIMEO
  /////////////////////////////////////////////////////////////
  embetter.services.vimeo = {
    type: 'vimeo',
    dataAttribute: 'data-vimeo-id',
    regex: embetter.utils.buildRegex('vimeo.com\/(\\S*)'),
    embed: function(id, w, h, autoplay, poster) {
      var autoplayQuery = (autoplay == true) ? '&amp;autoplay=1' : '';
      return '<iframe id="' + id + '" src="//player.vimeo.com/video/'+ id +'?title=0&amp;byline=0&amp;portrait=0&amp;color=ffffff&amp;api=1&amp;player_id=' + id + autoplayQuery +'" width="'+ w +'" height="'+ h +'" frameborder="0" scrolling="no" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'https://vimeo.com/' + id;
    },
    loadAPI: function(apiLoadedCallback) {
      var self = this;
      if(typeof window.Froogaloop !== 'undefined') {
        apiLoadedCallback();
        self.activateCurrentPlayer();
        return;
      }
      // docs here: https://developer.vimeo.com/player/js-api
      // requires &api=1 above to connect to an existing iframe
      embetter.utils.loadRemoteScript("https://f.vimeocdn.com/js/froogaloop2.min.js");

      var vimeoApiLoad = setInterval(function() {
        if(typeof window.Froogaloop !== 'undefined') {
          window.clearInterval(vimeoApiLoad);
          apiLoadedCallback();
          self.activateCurrentPlayer();
        }
      }, 50);
    },
    activateCurrentPlayer: function() {
      this.currentIframe = document.querySelector('.embetter-playing[data-vimeo-id] iframe');
      this.currentIframe.id = document.querySelector('.embetter-playing').getAttribute('data-vimeo-id'); // set the id on the iframe to match `player_id` query param
      if (this.currentIframe.id) {
        var self = this;
        this.apiPlayer = $f(this.currentIframe);
        this.apiPlayer.addEvent('ready', function() {
          self.apiPlayer.addEvent('pause', function(id) {});
          self.apiPlayer.addEvent('finish', function(id) {
            embetter.utils.mediaComplete();
          });
          self.apiPlayer.addEvent('playProgress', function(data, id) {});
        });
      }
    }
  };


  /////////////////////////////////////////////////////////////
  // SOUNDCLOUD
  // https://soundcloud.com/pages/embed
  // https://developers.soundcloud.com/docs/api/sdks
  // http://soundcloud.com/oembed?format=js&url=https%3A//soundcloud.com/cacheflowe/patter&iframe=true
  /////////////////////////////////////////////////////////////
  embetter.services.soundcloud = {
    type: 'soundcloud',
    dataAttribute: 'data-soundcloud-id',
    regex: embetter.utils.buildRegex('(?:soundcloud.com|snd.sc)\\/([a-zA-Z0-9_-]*(?:\\/sets)?(?:\\/groups)?\\/[a-zA-Z0-9_-]*)'),
    embed: function(id, w, h, autoplay, poster) {
      var autoplayQuery = (autoplay == true) ? '&amp;auto_play=true' : '';
      if(!id.match(/^(playlist|track|group)/)) id = 'tracks/' + id; // if no tracks/sound-id, prepend tracks/ (mostly for legacy compatibility)
      return '<iframe id="sc-widget" width="100%" height="600" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/'+ id + autoplayQuery +'&amp;hide_related=false&amp;color=373737&amp;show_comments=false&amp;show_user=true&amp;show_reposts=false&amp;visual=true"></iframe>';
    },
    link: function(id) {
      return 'https://soundcloud.com/' + id;
    },
    loadAPI: function(apiLoadedCallback) {
      var self = this;
      if(typeof window.SC !== 'undefined') {
        apiLoadedCallback();
        self.activateCurrentPlayer();
        return;
      }
      // docs here: https://developers.soundcloud.com/docs/api/html5-widget#resources
      // and: https://developers.soundcloud.com/blog/html5-widget-api
      embetter.utils.loadRemoteScript("https://w.soundcloud.com/player/api.js");
      // creates an <iframe> (and YouTube player) after the API code downloads.
      var soundcloudApiLoad = setInterval(function() {
        if(typeof window.SC !== 'undefined') {
          window.clearInterval(soundcloudApiLoad);
          apiLoadedCallback();
          self.activateCurrentPlayer();
        }
      }, 50);
    },
    activateCurrentPlayer: function() {
      this.currentIframe = document.querySelector('.embetter-playing[data-soundcloud-id] iframe');
      this.currentIframe.id = document.querySelector('.embetter-playing').getAttribute('data-soundcloud-id'); // set the id on the iframe
      if (this.currentIframe.id) {
        widget = SC.Widget(this.currentIframe);
        widget.bind(SC.Widget.Events.READY, function() {
          widget.bind(SC.Widget.Events.FINISH, function() {
            embetter.utils.mediaComplete();
          });
        });
      }
    }
  };


  /////////////////////////////////////////////////////////////
  // INSTAGRAM
  // http://instagram.com/p/fA9uwTtkSN/media/?size=l
  // https://instagram.com/p/fA9uwTtkSN/embed/
  // http://api.instagram.com/oembed?url=http://instagr.am/p/fA9uwTtkSN/?blah
  /////////////////////////////////////////////////////////////
  embetter.services.instagram = {
    type: 'instagram',
    dataAttribute: 'data-instagram-id',
    regex: embetter.utils.buildRegex('(?:instagram.com|instagr.am)\/p\/([a-zA-Z0-9-_]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="100%" height="600" scrolling="no" frameborder="no" src="https://instagram.com/p/'+ id +'/embed/"></iframe>';
    },
    link: function(id) {
      return 'https://instagram.com/p/' + id +'/';
    }
  };


  /////////////////////////////////////////////////////////////
  // DAILYMOTION
  /////////////////////////////////////////////////////////////
  embetter.services.dailymotion = {
    type: 'dailymotion',
    dataAttribute: 'data-dailymotion-id',
    regex: embetter.utils.buildRegex('dailymotion.com\/video\/([a-zA-Z0-9-_]*)'),
    embed: function(id, w, h, autoplay, poster) {
      var autoplayQuery = (autoplay == true) ? '?autoPlay=1' : '';
      return '<iframe class="video" width="'+ w +'" height="'+ h +'" src="//www.dailymotion.com/embed/video/'+ id + autoplayQuery +'" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'http://www.dailymotion.com/video/'+ id;
    }
  };


  /////////////////////////////////////////////////////////////
  // MIXCLOUD
  /////////////////////////////////////////////////////////////
  embetter.services.mixcloud = {
    type: 'mixcloud',
    dataAttribute: 'data-mixcloud-id',
    regex: embetter.utils.buildRegex('(?:mixcloud.com)\\/(.*\\/.*)'),
    embed: function(id, w, h, autoplay, poster) {
      var autoplayQuery = (autoplay == true) ? '&amp;autoplay=true' : '';
      return '<iframe width="660" height="180" src="https://www.mixcloud.com/widget/iframe/?feed=' + window.escape('http://www.mixcloud.com/' + id) + '&amp;replace=0&amp;hide_cover=1&amp;stylecolor=ffffff&amp;embed_type=widget_standard&amp;'+ autoplayQuery +'" frameborder="0" scrolling="no"></iframe>';
    },
    link: function(id) {
      return 'https://www.mixcloud.com/' + id;
    }
  };


  /////////////////////////////////////////////////////////////
  // CODEPEN
  /////////////////////////////////////////////////////////////
  embetter.services.codepen = {
    type: 'codepen',
    dataAttribute: 'data-codepen-id',
    regex: embetter.utils.buildRegex('(?:codepen.io)\\/([a-zA-Z0-9_\\-%]*\\/[a-zA-Z0-9_\\-%]*\\/[a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
     id = id.replace('/pen/', '/embed/');
     var user = id.split('/')[0];
     var slugHash = id.split('/')[2];
     return '<iframe src="//codepen.io/' + id + '?height=' + h + '&amp;theme-id=0&amp;slug-hash=' + slugHash + '&amp;default-tab=result&amp;user=' + user + '" frameborder="0" scrolling="no" allowtransparency="true" allowfullscreen="true"></iframe>';
    },
    link: function(id) {
      id = id.replace('/embed/', '/pen/');
      return 'http://codepen.io/' + id;
    }
  };


  /////////////////////////////////////////////////////////////
  // BANDCAMP
  // https://swindleuk.bandcamp.com/album/swindle-walters-call
  // <meta property="twitter:player" content="https://bandcamp.com/EmbeddedPlayer/v=2/album=2659930103/size=large/linkcol=0084B4/notracklist=true/twittercard=true/" />
  // <link rel="image_src" href="https://f1.bcbits.com/img/a0883249002_16.jpg">
  // <meta property="og:image" content="https://f1.bcbits.com/img/a0883249002_16.jpg">
  // <meta property="twitter:player" content="https://bandcamp.com/EmbeddedPlayer/v=2/track=1572756071/size=large/linkcol=0084B4/notracklist=true/twittercard=true/" />
  // <meta property="twitter:image" content="https://f1.bcbits.com/img/a0883249002_2.jpg" />
  // https://f1.bcbits.com/img/a0883249002_16.jpg
  /////////////////////////////////////////////////////////////
  embetter.services.bandcamp = {
    type: 'bandcamp',
    dataAttribute: 'data-bandcamp-id',
    regex: embetter.utils.buildRegex('([a-zA-Z0-9_\\-]*.bandcamp.com\\/(album|track)\\/[a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe src="https://bandcamp.com/EmbeddedPlayer/' + id + '/size=large/bgcol=ffffff/linkcol=333333/tracklist=true/artwork=small/transparent=true/" frameborder="0" scrolling="no" allowtransparency="true" allowfullscreen="true" seamless></iframe>';
    },
    link: function(id) {
      return 'https://'+id;
    }
  };


  /////////////////////////////////////////////////////////////
  // USTREAM
  // https://ustream.zendesk.com/entries/52568684-Using-URL-Parameters-and-the-Ustream-Embed-API-for-Custom-Players
  // http://www.ustream.tv/recorded/*
  // http://www.ustream.tv/*
  // http://ustre.am/*
  /////////////////////////////////////////////////////////////
  embetter.services.ustream = {
    type: 'ustream',
    dataAttribute: 'data-ustream-id',
    regex: embetter.utils.buildRegex('(?:ustream.tv|ustre.am)\\/((?:(recorded|channel)\\/)?[a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      var autoplayQuery = (autoplay == true) ? '&amp;autoplay=true' : '';
      return '<iframe width="480" height="300" src="http://www.ustream.tv/embed/' + id + '?' + autoplayQuery + '" frameborder="0" scrolling="no" allowtransparency="true" allowfullscreen="true"></iframe>';
    },
    link: function(id) {
      return 'http://www.ustream.tv/'+id;
    }
  };


  /////////////////////////////////////////////////////////////
  // IMGUR
  // look at this URL: http://imgur.com/gallery/u063r and remove "gallery/" to get a completely different embed
  // http://api.imgur.com/oembed.json?url=http://imgur.com/gallery/u063r
  // look for: <meta name="twitter:card" content="gallery"/> - this lets us prepend "a/" before id to get the gallery embed
  // gallery mode indicator: <meta name="twitter:card" content="gallery"/>
  // gallery embed id: a/u063r
  // gallery embed thumb: first og:image
  // image embed id: u063r
  // image embed thumb: u063r
  /////////////////////////////////////////////////////////////
  embetter.services.imgur = {
    type: 'imgur',
    dataAttribute: 'data-imgur-id',
    regex: embetter.utils.buildRegex('(?:imgur.com)\\/((?:gallery\\/)?[a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="'+ w +'" height="'+ h +'" src="https://www.imgur.com/'+ id +'/embed" " frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'https://imgur.com/' + id;
    }
  };


  /////////////////////////////////////////////////////////////
  // VINE
  /////////////////////////////////////////////////////////////
  embetter.services.vine = {
    type: 'vine',
    dataAttribute: 'data-vine-id',
    regex: embetter.utils.buildRegex('vine.co\\/v\\/([a-zA-Z0-9-]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="'+ w +'" height="'+ h +'" src="https://vine.co/v/'+ id +'/card?mute=1" " frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'https://vine.co/v/' + id;
    }
  };


  /////////////////////////////////////////////////////////////
  // SLIDESHARE
  // http://www.slideshare.net/developers/oembed
  // http://www.slideshare.net/api/oembed/2?url=http://www.slideshare.net/tedxseoul/the-inaugural-tedxseoul-teaser&format=json
  /////////////////////////////////////////////////////////////
  embetter.services.slideshare = {
    type: 'slideshare',
    dataAttribute: 'data-slideshare-id',
    regex: embetter.utils.buildRegex('slideshare.net\\/([a-zA-Z0-9_\\-%]*\\/[a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="427" height="356" src="https://www.slideshare.net/slideshow/embed_code/key/'+ id + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'https://www.slideshare.net/' + id;
    }
  };


  /////////////////////////////////////////////////////////////
  // GIPHY
  /////////////////////////////////////////////////////////////
  embetter.services.giphy = {
    type: 'giphy',
    dataAttribute: 'data-giphy-id',
    regex: embetter.utils.buildRegex('giphy.com\\/gifs\\/([a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="'+ w +'" height="'+ h +'" src="https://giphy.com/embed/'+ id + '/twitter/iframe" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(dashedId) {
      return 'https://giphy.com/gifs/' + dashedId;
    }
  };


  /////////////////////////////////////////////////////////////
  // SHADERTOY
  /////////////////////////////////////////////////////////////
  embetter.services.shadertoy = {
    type: 'shadertoy',
    dataAttribute: 'data-shadertoy-id',
    regex: embetter.utils.buildRegex('shadertoy.com\\/view\\/([a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="'+ w +'" height="'+ h +'" src="https://www.shadertoy.com/embed/'+ id + '?gui=true&t=10&paused=false&muted=false" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'https://www.shadertoy.com/view/' + id;
    }
  };


  /////////////////////////////////////////////////////////////
  // KUULA
  /////////////////////////////////////////////////////////////
  embetter.services.kuula = {
    type: 'kuula',
    dataAttribute: 'data-kuula-id',
    regex: embetter.utils.buildRegex('kuula.co\\/post\\/([a-zA-Z0-9_\\-%]*)'),
    embed: function(id, w, h, autoplay, poster) {
      return '<iframe width="'+ w +'" height="'+ h +'" src="http://www.kuula.co/share/'+ id + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
    },
    link: function(id) {
      return 'http://www.kuula.co/post/' + id;
    }
  };


  // /////////////////////////////////////////////////////////////
  // // FLICKR
  // // http://*.flickr.com/photos/*
  // // http://flic.kr/p/*
  // /////////////////////////////////////////////////////////////
  // embetter.services.flickr = {
  //   type: 'flickr',
  //   dataAttribute: 'data-flickr-id',
  //   regex: embetter.utils.buildRegex('flickr.com\\/photos\\/([a-zA-Z0-9_\\-%]*)\\/([a-zA-Z0-9_\\-%]*)'),
  //   embed: function(id, w, h, autoplay, poster) {
  //     // return '<iframe width="'+ w +'" height="'+ h +'" src="'+ id + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowfullscreen></iframe>';
  //     return '<img class="img" width="'+ w +'" height="'+ h +'" src="'+ id + '">';
  //   },
  //   link: function(user, photoId) {
  //     return 'https://www.flickr.com/photos/' + user + '/' + photoId + '/';
  //   }
  // };


  /////////////////////////////////////////////////////////////
  // MEDIA PLAYER INSTANCE
  /////////////////////////////////////////////////////////////

  embetter.curPlayer = null;

  embetter.EmbetterPlayer = function(el, serviceObj) {
    this.el = el;
    this.el.classList.add('embetter-ready');
    this.serviceObj = serviceObj;
    this.id = this.el.getAttribute(serviceObj.dataAttribute);
    this.thumbnail = this.el.querySelector('img');
    this.playerEl = null;
    this.buildPlayButton();
    this.checkForBadThumbnail();
  };

  embetter.EmbetterPlayer.prototype.buildPlayButton = function() {
    this.playButton = document.createElement('div');
    this.playButton.classList.add('embetter-loading');
    this.el.appendChild(this.playButton);

    this.playButton = document.createElement('div');
    this.playButton.classList.add('embetter-play-button');
    this.el.appendChild(this.playButton);

    var self = this;
    this.playHandler = function() { self.play(); }; // for event listener removal
    this.playButton.addEventListener('click', this.playHandler);
  };

  embetter.EmbetterPlayer.prototype.checkForBadThumbnail = function() {
    var self = this;
    // try to detect onerror
    this.thumbnail.onerror = function() {
      self.fallbackThumbnail();
    };
    // if onerror already happened but we still have a broken image, give it 4 seconds to load, then replace
    setTimeout(function() {
      if(self.thumbnail.height < 50) {
        self.fallbackThumbnail();
      }
    }, 4000);
  };

  embetter.EmbetterPlayer.prototype.fallbackThumbnail = function() {
    this.thumbnail.src = embetter.defaultThumbnail;
  };

  embetter.EmbetterPlayer.prototype.getType = function() {
    return this.serviceObj.type;
  };

  embetter.EmbetterPlayer.prototype.play = function() {
    if(embetter.curPlayer != null) {
      embetter.curPlayer.unembedMedia();
      embetter.curPlayer = null;
    }

    var self = this;
    var startPlaying = function() {
      self.embedMedia(true);
      embetter.curPlayer = self;
    };
    // load API if one exists for service, otherwise just play
    if(this.serviceObj.loadAPI && embetter.apiEnabled == true && embetter.utils.isMobile == false) {
      this.serviceObj.loadAPI(startPlaying);
    } else {
      startPlaying();
    }
  };

  embetter.EmbetterPlayer.prototype.unembedMedia = function() {
    if(this.playerEl != null && this.playerEl.parentNode != null) {
      this.playerEl.parentNode.removeChild(this.playerEl);
    }
    this.el.classList.remove('embetter-playing');
  };

  // embed if mobile
  embetter.EmbetterPlayer.prototype.embedMedia = function(autoplay) {
    if(this.el.classList.contains('embetter-playing') == true) return;
    if(this.id != null) this.playerEl = embetter.utils.stringToDomElement(this.serviceObj.embed(this.id, this.thumbnail.width, this.thumbnail.height, autoplay, this.thumbnail.src));
    this.el.appendChild(this.playerEl);
    this.el.classList.add('embetter-playing');
  };

  embetter.EmbetterPlayer.prototype.dispose = function() {
    this.el.classList.remove('embetter-ready');
    this.unembedMedia();
    this.playButton.removeEventListener('click', this.playHandler);
    if(this.playButton != null && this.playButton.parentNode != null) {
      this.playButton.parentNode.removeChild(this.playButton);
    }
  };
})();

/*! medium-zoom 1.0.4 | MIT License | https://github.com/francoischalifour/medium-zoom */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.mediumZoom=t()}(this,function(){"use strict";var H=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e},o=function(e){return"IMG"===e.tagName},C=function(e){return e&&1===e.nodeType},O=function(e){return".svg"===(e.currentSrc||e.src).substr(-4).toLowerCase()},c=function(e){try{return Array.isArray(e)?e.filter(o):(t=e,NodeList.prototype.isPrototypeOf(t)?[].slice.call(e).filter(o):C(e)?[e].filter(o):"string"==typeof e?[].slice.call(document.querySelectorAll(e)).filter(o):[])}catch(e){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}var t},x=function(e,t){var o=H({bubbles:!1,cancelable:!1,detail:void 0},t);if("function"==typeof window.CustomEvent)return new CustomEvent(e,o);var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,o.bubbles,o.cancelable,o.detail),n};return function(e,t){void 0===t&&(t={});var o=t.insertAt;if(e&&"undefined"!=typeof document){var n=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===o&&n.firstChild?n.insertBefore(i,n.firstChild):n.appendChild(i),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(document.createTextNode(e))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}"),function t(e){var o=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=window.Promise||function(e){function t(){}e(t,t)},i=function(){for(var e=arguments.length,t=Array(e),o=0;o<e;o++)t[o]=arguments[o];var i=t.reduce(function(e,t){return[].concat(e,c(t))},[]);return i.filter(function(e){return-1===v.indexOf(e)}).forEach(function(e){v.push(e),e.classList.add("medium-zoom-image")}),m.forEach(function(e){var t=e.type,o=e.listener,n=e.options;i.forEach(function(e){e.addEventListener(t,o,n)})}),L},d=function(){var p=(0<arguments.length&&void 0!==arguments[0]?arguments[0]:{}).target,g=function(){var e={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},t=void 0,o=void 0;if(b.container)if(b.container instanceof Object)t=(e=H({},e,b.container)).width-e.left-e.right-2*b.margin,o=e.height-e.top-e.bottom-2*b.margin;else{var n=(C(b.container)?b.container:document.querySelector(b.container)).getBoundingClientRect(),i=n.width,d=n.height,r=n.left,m=n.top;e=H({},e,{width:i,height:d,left:r,top:m})}t=t||e.width-2*b.margin,o=o||e.height-2*b.margin;var a=E.zoomedHd||E.original,l=O(a)?t:a.naturalWidth||t,c=O(a)?o:a.naturalHeight||o,u=a.getBoundingClientRect(),s=u.top,f=u.left,p=u.width,g=u.height,h=Math.min(l,t)/p,v=Math.min(c,o)/g,z=Math.min(h,v),y="scale("+z+") translate3d("+((t-p)/2-f+b.margin+e.left)/z+"px, "+((o-g)/2-s+b.margin+e.top)/z+"px, 0)";E.zoomed.style.transform=y,E.zoomedHd&&(E.zoomedHd.style.transform=y)};return new n(function(t){if(p&&-1===v.indexOf(p))t(L);else if(E.zoomed)t(L);else{if(p)E.original=p;else{if(!(0<v.length))return void t(L);var e=v;E.original=e[0]}var o,n,i,d,r,m,a,l,c;if(E.original.dispatchEvent(x("medium-zoom:open",{detail:{zoom:L}})),y=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,z=!0,E.zoomed=(o=E.original,n=o.getBoundingClientRect(),i=n.top,d=n.left,r=n.width,m=n.height,a=o.cloneNode(),l=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,c=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0,a.removeAttribute("id"),a.style.position="absolute",a.style.top=i+l+"px",a.style.left=d+c+"px",a.style.width=r+"px",a.style.height=m+"px",a.style.transform="",a),document.body.appendChild(w),b.template){var u=C(b.template)?b.template:document.querySelector(b.template);E.template=document.createElement("div"),E.template.appendChild(u.content.cloneNode(!0)),document.body.appendChild(E.template)}if(document.body.appendChild(E.zoomed),window.requestAnimationFrame(function(){document.body.classList.add("medium-zoom--opened")}),E.original.classList.add("medium-zoom-image--hidden"),E.zoomed.classList.add("medium-zoom-image--opened"),E.zoomed.addEventListener("click",h),E.zoomed.addEventListener("transitionend",function e(){z=!1,E.zoomed.removeEventListener("transitionend",e),E.original.dispatchEvent(x("medium-zoom:opened",{detail:{zoom:L}})),t(L)}),E.original.getAttribute("data-zoom-src")){E.zoomedHd=E.zoomed.cloneNode(),E.zoomedHd.removeAttribute("srcset"),E.zoomedHd.removeAttribute("sizes"),E.zoomedHd.src=E.zoomed.getAttribute("data-zoom-src"),E.zoomedHd.onerror=function(){clearInterval(s),console.warn("Unable to reach the zoom image target "+E.zoomedHd.src),E.zoomedHd=null,g()};var s=setInterval(function(){E.zoomedHd.complete&&(clearInterval(s),E.zoomedHd.classList.add("medium-zoom-image--opened"),E.zoomedHd.addEventListener("click",h),document.body.appendChild(E.zoomedHd),g())},10)}else if(E.original.hasAttribute("srcset")){E.zoomedHd=E.zoomed.cloneNode(),E.zoomedHd.removeAttribute("sizes");var f=E.zoomedHd.addEventListener("load",function(){E.zoomedHd.removeEventListener("load",f),E.zoomedHd.classList.add("medium-zoom-image--opened"),E.zoomedHd.addEventListener("click",h),document.body.appendChild(E.zoomedHd),g()})}else g()}})},h=function(){return new n(function(t){!z&&E.original?(z=!0,document.body.classList.remove("medium-zoom--opened"),E.zoomed.style.transform="",E.zoomedHd&&(E.zoomedHd.style.transform=""),E.template&&(E.template.style.transition="opacity 150ms",E.template.style.opacity=0),E.original.dispatchEvent(x("medium-zoom:close",{detail:{zoom:L}})),E.zoomed.addEventListener("transitionend",function e(){E.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(E.zoomed),E.zoomedHd&&document.body.removeChild(E.zoomedHd),document.body.removeChild(w),E.zoomed.classList.remove("medium-zoom-image--opened"),E.template&&document.body.removeChild(E.template),z=!1,E.zoomed.removeEventListener("transitionend",e),E.original.dispatchEvent(x("medium-zoom:closed",{detail:{zoom:L}})),E.original=null,E.zoomed=null,E.zoomedHd=null,E.template=null,t(L)})):t(L)})},r=function(){var e=(0<arguments.length&&void 0!==arguments[0]?arguments[0]:{}).target;return E.original?h():d({target:e})},v=[],m=[],z=!1,y=0,b=o,E={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?b=e:(e||"string"==typeof e)&&i(e),b=H({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},b);var a,l,w=(a=b.background,(l=document.createElement("div")).classList.add("medium-zoom-overlay"),l.style.background=a,l);document.addEventListener("click",function(e){var t=e.target;t!==w?-1!==v.indexOf(t)&&r({target:t}):h()}),document.addEventListener("keyup",function(e){27===(e.keyCode||e.which)&&h()}),document.addEventListener("scroll",function(){if(!z&&E.original){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(y-e)>b.scrollOffset&&setTimeout(h,150)}}),window.addEventListener("resize",h);var L={open:d,close:h,toggle:r,update:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=e;if(e.background&&(w.style.background=e.background),e.container&&e.container instanceof Object&&(t.container=H({},b.container,e.container)),e.template){var o=C(e.template)?e.template:document.querySelector(e.template);t.template=o}return b=H({},b,t),v.forEach(function(e){e.dispatchEvent(x("medium-zoom:update",{detail:{zoom:L}}))}),L},clone:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return t(H({},b,e))},attach:i,detach:function(){for(var e=arguments.length,t=Array(e),o=0;o<e;o++)t[o]=arguments[o];E.zoomed&&h();var n=0<t.length?t.reduce(function(e,t){return[].concat(e,c(t))},[]):v;return n.forEach(function(e){e.classList.remove("medium-zoom-image"),e.dispatchEvent(x("medium-zoom:detach",{detail:{zoom:L}}))}),v=v.filter(function(e){return-1===n.indexOf(e)}),L},on:function(t,o){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};return v.forEach(function(e){e.addEventListener("medium-zoom:"+t,o,n)}),m.push({type:"medium-zoom:"+t,listener:o,options:n}),L},off:function(t,o){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};return v.forEach(function(e){e.removeEventListener("medium-zoom:"+t,o,n)}),m=m.filter(function(e){return!(e.type==="medium-zoom:"+t&&e.listener.toString()===o.toString())}),L},getOptions:function(){return b},getImages:function(){return v},getZoomedImage:function(){return E.original}};return L}});

var Notyf=function(){"use strict";var e,t,o=function(){return(o=Object.assign||function(t){for(var i,n=1,e=arguments.length;n<e;n++)for(var o in i=arguments[n])Object.prototype.hasOwnProperty.call(i,o)&&(t[o]=i[o]);return t}).apply(this,arguments)},a=function(t){this.options=t};(t=e||(e={}))[t.Add=0]="Add",t[t.Remove=1]="Remove";var s=function(){function t(){this.notifications=[]}return t.prototype.push=function(t){this.notifications.push(t),this.updateFn(t,e.Add,this.notifications)},t.prototype.splice=function(t,i){var n=this.notifications.splice(t,i)[0];this.updateFn(n,e.Remove,this.notifications)},t.prototype.indexOf=function(t){return this.notifications.indexOf(t)},t.prototype.onupdate=function(t){this.updateFn=t},t}(),r={types:[{type:"success",className:"notyf__toast--success",backgroundColor:"#3dc763",icon:{className:"notyf__icon--success",tagName:"i"}},{type:"error",className:"notyf__toast--error",backgroundColor:"#ed3d3d",icon:{className:"notyf__icon--error",tagName:"i"}}],duration:2e3,ripple:!0},c=function(){function t(){this.notifications=[];var t=document.createDocumentFragment(),i=this._createHTLMElement({tagName:"div",className:"notyf"});t.appendChild(i),document.body.appendChild(t),this.container=i,this.animationEndEventName=this._getAnimationEndEventName(),this._createA11yContainer()}return t.prototype.update=function(t,i){i===e.Add?this.addNotification(t):i===e.Remove&&this.removeNotification(t)},t.prototype.removeNotification=function(t){var i,n,e=this,o=this._popRenderedNotification(t);o&&((i=o.node).classList.add("notyf__toast--disappear"),i.addEventListener(this.animationEndEventName,n=function(t){t.target===i&&(i.removeEventListener(e.animationEndEventName,n),e.container.removeChild(i))}))},t.prototype.addNotification=function(t){var i=this._renderNotification(t);this.notifications.push({notification:t,node:i}),this._announce(t.options.message||"Notification")},t.prototype._renderNotification=function(t){var i=this._buildNotificationCard(t),n=t.options.className;return n&&i.classList.add(n),this.container.appendChild(i),i},t.prototype._popRenderedNotification=function(t){for(var i=-1,n=0;n<this.notifications.length&&i<0;n++)this.notifications[n].notification===t&&(i=n);if(-1!==i)return this.notifications.splice(i,1)[0]},t.prototype._buildNotificationCard=function(t){var i=t.options,n=i.icon,e=this._createHTLMElement({tagName:"div",className:"notyf__toast"}),o=this._createHTLMElement({tagName:"div",className:"notyf__ripple"}),a=this._createHTLMElement({tagName:"div",className:"notyf__wrapper"}),s=this._createHTLMElement({tagName:"div",className:"notyf__message"});s.innerHTML=i.message||"";var r=i.backgroundColor;if(n&&"object"==typeof n){var c=this._createHTLMElement({tagName:"div",className:"notyf__icon"}),p=this._createHTLMElement({tagName:n.tagName||"i",className:n.className,text:n.text});r&&(p.style.color=r),c.appendChild(p),a.appendChild(c)}return a.appendChild(s),e.appendChild(a),r&&(i.ripple?(o.style.backgroundColor=r,e.appendChild(o)):e.style.backgroundColor=r),e},t.prototype._createHTLMElement=function(t){var i=t.tagName,n=t.className,e=t.text,o=document.createElement(i);return n&&(o.className=n),o.textContent=e||null,o},t.prototype._createA11yContainer=function(){var t=this._createHTLMElement({tagName:"div",className:"notyf-announcer"});t.setAttribute("aria-atomic","true"),t.setAttribute("aria-live","polite"),t.style.border="0",t.style.clip="rect(0 0 0 0)",t.style.height="1px",t.style.margin="-1px",t.style.overflow="hidden",t.style.padding="0",t.style.position="absolute",t.style.width="1px",t.style.outline="0",document.body.appendChild(t),this.a11yContainer=t},t.prototype._announce=function(t){var i=this;this.a11yContainer.textContent="",setTimeout(function(){i.a11yContainer.textContent=t},100)},t.prototype._getAnimationEndEventName=function(){var t,i=document.createElement("_fake"),n={MozTransition:"animationend",OTransition:"oAnimationEnd",WebkitTransition:"webkitAnimationEnd",transition:"animationend"};for(t in n)if(void 0!==i.style[t])return n[t];return"animationend"},t}();return function(){function t(t){var n=this;this.notifications=new s,this.view=new c;var i=this.registerTypes(t);this.options=o({},r,t),this.options.types=i,this.notifications.onupdate(function(t,i){n.view.update(t,i)})}return t.prototype.error=function(t){var i=this.normalizeOptions("error",t);this.open(i)},t.prototype.success=function(t){var i=this.normalizeOptions("success",t);this.open(i)},t.prototype.open=function(i){var t=this.options.types.find(function(t){return t.type===i.type})||{},n=o({},t,i);n.ripple=void 0===n.ripple?this.options.ripple:n.ripple;var e=new a(n);this._pushNotification(e)},t.prototype._pushNotification=function(i){var n=this;this.notifications.push(i);var t=i.options.duration||this.options.duration;setTimeout(function(){var t=n.notifications.indexOf(i);n.notifications.splice(t,1)},t)},t.prototype.normalizeOptions=function(t,i){var n={type:t};return"string"==typeof i?n.message=i:"object"==typeof i&&(n=o({},n,i)),n},t.prototype.registerTypes=function(t){var e=(t&&t.types||[]).slice();return r.types.map(function(i){var t=e.findIndex(function(t){return t.type===i.type}),n=-1!==t?e.splice(t,1)[0]:{};return o({},i,n)}).concat(e)},t}()}();
